<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Tree - TahriTech</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: radial-gradient(circle at 50% 50%, #0a3d0a 0%, #1a5e1a 40%, #0a0a0a 100%);
            color: #fff;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            background: radial-gradient(circle at 50% 50%, #b6ffb6 0%, #1a5e1a 60%, #0a3d0a 100%);
        }
        
        /* Title page header */
        #header-title {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            color: white;
            opacity: 0;
            transition: opacity 0.8s ease 0.5s;
            background: rgba(0, 0, 0, 0.75);
            padding: 20px 40px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        #header-title.visible {
            opacity: 1;
        }
        
        #header-title h1 {
            font-size: 48px;
            margin: 0 0 10px 0;
            font-weight: 700;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6),
                         0 0 40px rgba(0, 255, 255, 0.4);
            letter-spacing: 2px;
        }
        
        #header-title p {
            font-size: 16px;
            margin: 0;
            color: #88ddff;
            opacity: 0.9;
        }
        
        /* Projects Header - Collapsible */
        #projects-header {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            width: 100%;
            max-width: 800px;
            background: linear-gradient(180deg, rgba(0, 20, 40, 0.98), rgba(0, 40, 60, 0.95));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-top: none;
            border-radius: 0 0 20px 20px;
            padding: 20px 30px;
            z-index: 150;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.4);
        }
        
        #projects-header.expanded {
            transform: translateX(-50%) translateY(0);
        }
        
        #legend-toggle-container {
            position: fixed;
            top: 10px;
            left: 20px;
            z-index: 160;
        }
        
        #legend-toggle {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.6);
            color: #00ffff;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 28px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
            animation: mapGlow 3s ease-in-out infinite;
            transform-origin: center center;
        }
        
        @keyframes mapGlow {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 4px 25px rgba(0, 255, 255, 0.6), 0 0 15px rgba(0, 255, 255, 0.4);
            }
        }
        
        #legend-toggle:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(0, 255, 255, 0.5);
            animation: none;
        }
        
        #legend-toggle.expanded {
            animation: mapBounce 0.6s ease-out, mapGlow 3s ease-in-out infinite;
            transform: scale(1.1);
        }
        
        @keyframes mapBounce {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1.1);
            }
        }

        /* Theme Toggle Button */
        #theme-toggle {
            position: fixed;
            top: 10px;
            right: 80px; /* Next to projects button */
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.6);
            color: #00ffff;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 160;
            font-size: 24px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        #theme-toggle:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5);
        }

        /* Resume Toggle Button */
        #resume-toggle {
            position: fixed;
            top: 10px;
            right: 140px; /* Next to theme button */
            background: rgba(139, 90, 43, 0.2);
            border: 2px solid rgba(139, 90, 43, 0.6);
            color: #8B5A2B;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 160;
            font-size: 24px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 90, 43, 0.3);
        }

        #resume-toggle:hover {
            background: rgba(139, 90, 43, 0.4);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(139, 90, 43, 0.5);
        }

        /* Resume Paper Plane */
        #resume-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            max-width: 700px;
            height: 75vh;
            max-height: 900px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: none;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 50px 60px;
            opacity: 0;
            transition: opacity 1s ease-in;
        }

        #resume-container.visible {
            display: block;
            opacity: 1;
        }
        
        #resume-container::-webkit-scrollbar {
            width: 8px;
        }
        
        #resume-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        #resume-container::-webkit-scrollbar-thumb {
            background: #8B5A2B;
            border-radius: 4px;
        }
        
        #resume-container::-webkit-scrollbar-thumb:hover {
            background: #6B4423;
        }

        #back-to-tree {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(139, 90, 43, 0.9);
            border: 2px solid rgba(139, 90, 43, 1);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 1001;
            font-size: 16px;
            transition: all 0.3s ease;
            display: none;
        }

        #back-to-tree.visible {
            display: block;
        }

        #back-to-tree:hover {
            background: rgba(139, 90, 43, 1);
            transform: scale(1.05);
        }

        /* Recycle/Replant Button */
        #recycle-tree {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(76, 175, 80, 0.9);
            border: 2px solid rgba(76, 175, 80, 1);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 1001;
            font-size: 16px;
            transition: all 0.3s ease;
            display: none;
        }

        #recycle-tree.visible {
            display: block;
        }

        #recycle-tree:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
        }

        /* Nature theme styling */
        body.nature-theme #theme-toggle {
            background: rgba(139, 69, 19, 0.3);
            border-color: rgba(101, 67, 33, 0.8);
            color: #8B4513;
            box-shadow: 0 4px 15px rgba(101, 67, 33, 0.3);
        }

        body.nature-theme #theme-toggle:hover {
            background: rgba(139, 69, 19, 0.5);
            box-shadow: 0 6px 20px rgba(101, 67, 33, 0.5);
        }
        
        /* Nature theme - Projects toggle */
        body.nature-theme #projects-toggle {
            background: rgba(101, 67, 33, 0.3);
            border-color: rgba(139, 69, 19, 0.6);
            color: #8B7355;
            box-shadow: 0 4px 15px rgba(101, 67, 33, 0.3);
            animation: fruitSwing 2s ease-in-out infinite, fruitGlowNature 3s ease-in-out infinite;
        }
        
        @keyframes fruitGlowNature {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(101, 67, 33, 0.3);
            }
            50% {
                box-shadow: 0 4px 25px rgba(101, 67, 33, 0.6), 0 0 15px rgba(101, 67, 33, 0.4);
            }
        }
        
        body.nature-theme #projects-toggle:hover {
            background: rgba(101, 67, 33, 0.5);
            box-shadow: 0 6px 25px rgba(101, 67, 33, 0.5);
        }
        
        /* Nature theme - Callout */
        body.nature-theme #skill-callout {
            background: linear-gradient(135deg, rgba(40, 30, 20, 0.95), rgba(60, 45, 30, 0.95));
            border-color: rgba(139, 69, 19, 0.6);
            box-shadow: 0 0 30px rgba(101, 67, 33, 0.4);
        }
        
        body.nature-theme #skill-callout h3 {
            color: #9ACD32; /* Yellow-green for headers */
        }
        
        body.nature-theme #skill-callout p {
            color: #D2B48C; /* Tan color for text */
        }
        
        /* Nature theme - Navigation arrows */
        body.nature-theme .nav-arrow-btn {
            background: rgba(101, 67, 33, 0.3);
            border-color: rgba(139, 69, 19, 0.8);
            color: #8B7355;
            box-shadow: 0 4px 20px rgba(101, 67, 33, 0.3);
            animation: pulse-glow-nature 2s ease-in-out infinite;
        }
        
        @keyframes pulse-glow-nature {
            0%, 100% {
                box-shadow: 0 4px 20px rgba(101, 67, 33, 0.3);
            }
            50% {
                box-shadow: 0 4px 30px rgba(101, 67, 33, 0.6), 0 0 15px rgba(101, 67, 33, 0.4);
            }
        }
        
        body.nature-theme .nav-arrow-btn:hover:not(:disabled) {
            background: rgba(101, 67, 33, 0.5);
            border-color: rgba(139, 69, 19, 1);
            box-shadow: 0 8px 40px rgba(101, 67, 33, 0.8);
            animation: none;
        }
        
        body.nature-theme .nav-arrow-btn:active:not(:disabled) {
            background: rgba(101, 67, 33, 0.4);
        }
        
        /* Nature theme - Legend */
        body.nature-theme #legend {
            background: rgba(40, 30, 20, 0.95);
            border-color: rgba(139, 69, 19, 0.6);
            box-shadow: 0 8px 32px rgba(101, 67, 33, 0.4);
        }
        
        body.nature-theme #legend h3 {
            color: #9ACD32;
        }
        
        body.nature-theme .legend-item {
            color: #D2B48C;
        }
        
        body.nature-theme #legend-toggle {
            background: rgba(101, 67, 33, 0.3);
            border-color: rgba(139, 69, 19, 0.6);
            color: #8B7355;
            box-shadow: 0 4px 15px rgba(101, 67, 33, 0.3);
        }
        
        body.nature-theme #legend-toggle:hover {
            background: rgba(101, 67, 33, 0.5);
            box-shadow: 0 6px 20px rgba(101, 67, 33, 0.5);
        }
        
        /* Nature theme - Header title */
        body.nature-theme #header-title h1 {
            color: #66BB6A;
            text-shadow: 0 0 20px rgba(102, 187, 106, 0.6),
                         0 0 40px rgba(102, 187, 106, 0.4);
        }
        
        body.nature-theme #header-title p {
            color: #9ACD32;
        }
        
        /* Nature theme - Projects header */
        body.nature-theme #projects-header {
            background: linear-gradient(180deg, rgba(40, 30, 20, 0.98), rgba(60, 45, 30, 0.95));
            border-color: rgba(139, 69, 19, 0.6);
            box-shadow: 0 10px 40px rgba(101, 67, 33, 0.4);
        }
        
        body.nature-theme #projects-header h2 {
            color: #66BB6A;
            text-shadow: 0 0 10px rgba(102, 187, 106, 0.5);
        }
        
        body.nature-theme .project-link {
            background: rgba(101, 67, 33, 0.2);
            border-color: rgba(139, 69, 19, 0.6);
            color: #9ACD32;
        }
        
        body.nature-theme .project-link:hover {
            background: rgba(101, 67, 33, 0.4);
            border-color: rgba(139, 69, 19, 0.9);
            box-shadow: 0 6px 20px rgba(101, 67, 33, 0.4);
        }
        
        /* Nature theme - Legend toggle animation */
        @keyframes mapGlowNature {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(101, 67, 33, 0.3);
            }
            50% {
                box-shadow: 0 4px 25px rgba(101, 67, 33, 0.6), 0 0 15px rgba(101, 67, 33, 0.4);
            }
        }
        
        body.nature-theme #legend-toggle {
            animation: mapGlowNature 3s ease-in-out infinite;
        }
        
        body.nature-theme #legend-toggle.expanded {
            animation: mapBounce 0.6s ease-out, mapGlowNature 3s ease-in-out infinite;
        }
        
        /* Nature theme - Skill detail panel */
        body.nature-theme #skill-detail {
            background: rgba(40, 30, 20, 0.95) !important;
            border-color: rgba(139, 69, 19, 0.8) !important;
            box-shadow: 0 0 20px rgba(102, 187, 106, 0.5) !important;
        }
        
        body.nature-theme #detail-name {
            color: #66BB6A !important;
        }
        
        body.nature-theme #detail-breadcrumb {
            color: #9ACD32 !important;
        }
        
        body.nature-theme #detail-additional {
            border-top-color: rgba(102, 187, 106, 0.3) !important;
        }
        
        body.nature-theme #close-detail {
            background: rgba(139, 69, 19, 0.3) !important;
            color: #9ACD32 !important;
        }
        
        body.nature-theme #close-detail:hover {
            background: rgba(139, 69, 19, 0.6) !important;
        }
        
        /* Nature theme - Roots toggle (mobile) */
        body.nature-theme #roots-toggle {
            background: rgba(101, 67, 33, 0.3);
            border-color: rgba(139, 69, 19, 0.6);
            color: #8B7355;
        }
        
        body.nature-theme #roots-toggle:hover {
            background: rgba(101, 67, 33, 0.5);
        }
        
        /* Tech theme - Roots panel (when switched from nature) */
        body:not(.nature-theme) #roots-panel {
            background: rgba(10, 10, 20, 0.95);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 -10px 40px rgba(0, 255, 255, 0.4);
        }
        
        body:not(.nature-theme) #roots-panel h2 {
            color: #00ffff; /* Cyan for tech theme */
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* Nature theme - Roots panel */
        body.nature-theme #roots-panel {
            /* To add roots background image, uncomment and set the path below: */
            /* background-image: url('path/to/roots-image.jpg'); */
            background: linear-gradient(to bottom, rgba(101, 67, 33, 0.98), rgba(139, 69, 19, 0.95), rgba(160, 100, 60, 0.9), rgba(180, 130, 90, 0.85));
            /* If using background image, you can overlay the gradient: */
            /* background: linear-gradient(to bottom, rgba(101, 67, 33, 0.9), rgba(139, 69, 19, 0.85), rgba(160, 100, 60, 0.8), rgba(180, 130, 90, 0.75)), url('path/to/roots-image.jpg'); */
            background-size: cover;
            background-position: center bottom;
            border-color: rgba(101, 67, 33, 0.6);
            box-shadow: 0 -10px 40px rgba(101, 67, 33, 0.4);
        }
        
        body.nature-theme #roots-panel h2 {
            color: #66BB6A; /* Green accent for roots header */
            text-shadow: 0 0 10px rgba(102, 187, 106, 0.5);
        }
        
        body.nature-theme .experience-item {
            background: rgba(102, 187, 106, 0.05);
            border-left-color: rgba(102, 187, 106, 0.6);
        }
        
        body.nature-theme .experience-item h4 {
            color: #66BB6A;
        }
        
        body.nature-theme .experience-item p {
            color: #81C784;
        }
        
        body.nature-theme .experience-item:hover {
            background: rgba(102, 187, 106, 0.1);
            border-left-color: rgba(102, 187, 106, 0.9);
        }
        
        body.nature-theme .experience-org {
            color: #9ACD32 !important;
        }
        
        body.nature-theme .experience-period {
            color: #66BB6A !important;
        }
        
        body.nature-theme .experience-desc {
            color: #A5D6A7 !important;
        }
        
        body.nature-theme .experience-item p strong {
            color: #66BB6A !important;
        }
        
        body.nature-theme .experience-icon {
            filter: hue-rotate(90deg) brightness(1.2);
        }
        
        body.nature-theme #roots-toggle {
            background: rgba(101, 67, 33, 0.3);
            border-color: rgba(139, 69, 19, 0.6);
            color: #8B7355;
        }
        
        /* Nature theme - Header title */
        body.nature-theme #header-title {
            color: #9ACD32;
            text-shadow: 0 0 20px rgba(154, 205, 50, 0.6), 
                         0 0 40px rgba(154, 205, 50, 0.4);
        }
        
        /* Nature theme - Trunk UI */
        body.nature-theme #skill-count {
            color: #8B7355;
        }
        
        body.nature-theme #zoom-controls button {
            background: rgba(101, 67, 33, 0.3);
            border-color: rgba(139, 69, 19, 0.6);
            color: #8B7355;
        }
        
        body.nature-theme #zoom-controls button:hover {
            background: rgba(101, 67, 33, 0.5);
        }

        #projects-toggle {
            position: fixed;
            top: 10px;
            right: 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.6);
            color: #00ffff;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 160;
            font-size: 28px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
            animation: fruitSwing 2s ease-in-out infinite, fruitGlow 3s ease-in-out infinite;
            transform-origin: top center;
        }
        
        @keyframes fruitSwing {
            0%, 100% { 
                transform: rotate(-10deg) scale(1);
            }
            25% {
                transform: rotate(10deg) scale(1.05);
            }
            50% {
                transform: rotate(-10deg) scale(1);
            }
            75% {
                transform: rotate(10deg) scale(1.05);
            }
        }
        
        @keyframes fruitGlow {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 4px 25px rgba(0, 255, 255, 0.6), 0 0 15px rgba(0, 255, 255, 0.4);
            }
        }
        
        #projects-toggle:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.2) rotate(15deg);
            box-shadow: 0 6px 25px rgba(0, 255, 255, 0.5);
            animation: none; /* Pause animation on hover */
        }
        
        #projects-toggle.expanded {
            animation: fruitBounce 0.6s ease-out, fruitGlow 3s ease-in-out infinite;
            transform: scale(1.1);
        }
        
        @keyframes fruitBounce {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1.1);
            }
        }
        
        #projects-header h2 {
            margin: 0 0 15px 0;
            color: #00ffff;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        #projects-links {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .project-link {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 25px;
            color: #00ffff;
            text-decoration: none;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .project-link:hover {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.4);
        }
        
        .project-link svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
            display: none; /* Hidden by default, shown on hover */
        }
        
        h1 {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        /* Seamless trunk extension UI */
        #trunk-ui {
            position: fixed;
            bottom: 280px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: bottom center;
            width: 4px;
            height: 200px;
            background: linear-gradient(to top, rgba(0, 255, 255, 0.8), transparent);
            pointer-events: none;
            z-index: 45;
            opacity: 0;
            transition: bottom 0.4s ease, 
                        opacity 0.8s ease 0.3s;
            will-change: transform, bottom;
        }
        
        #trunk-ui.loaded {
            opacity: 1;
        }
        
        #trunk-ui.collapsed {
            bottom: 60px; /* Position above the collapsed roots section */
            opacity: 1; /* Keep visible when collapsed */
        }
        
        /* Update trunk position dynamically based on roots panel */
        #trunk-ui.roots-expanded {
            bottom: 280px;
        }
        
        #roots-panel {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            width: 90%;
            max-width: 1400px;
            max-height: 80px; /* Collapsed by default */
            background: linear-gradient(to bottom, rgba(101, 67, 33, 0.98), rgba(139, 69, 19, 0.95), rgba(160, 100, 60, 0.9), rgba(180, 130, 90, 0.85));
            border: 2px solid rgba(101, 67, 33, 0.6);
            border-bottom: none;
            border-radius: 15px 15px 0 0;
            overflow: hidden;
            z-index: 50;
            box-shadow: 0 -10px 40px rgba(101, 67, 33, 0.4);
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.8s ease,
                        max-height 0.4s ease;
            cursor: pointer;
            background-size: cover;
            background-position: center bottom;
            background-repeat: no-repeat;
            /* Place background image here when you have one: */
            /* background-image: url('path/to/roots-background.jpg'), linear-gradient(...); */
            /* The gradient will show through or act as overlay depending on your needs */
        }
        
        #roots-panel:hover {
            max-height: 350px; /* Expand on hover */
        }
        
        #roots-panel.loaded {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        #roots-panel.collapsed {
            max-height: 60px; /* Show only the header title area */
            opacity: 1; /* Keep visible but collapsed */
            transform: translateX(-50%) translateY(0); /* Stay at bottom */
        }
        
        /* Expand toggle button for mobile */
        #roots-toggle {
            display: none;
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.6);
            color: #00ffff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 60;
            font-size: 24px;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        #roots-toggle:hover {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.1);
        }
        
        #roots-panel.expanded {
            max-height: 500px !important;
        }
        
        /* Mobile: single column */
        @media (max-width: 768px) {
            #roots-panel {
                width: 500px;
                max-width: 95%;
                max-height: 60px; /* Default collapsed state on mobile */
            }
            
            #roots-panel:hover {
                max-height: 60px; /* Disable hover expand on mobile */
            }
            
            #roots-panel.expanded {
                max-height: 280px !important; /* Full height when expanded */
            }
            
            #roots-toggle {
                display: block;
            }
            
            /* Move trunk UI down on mobile to align with roots panel */
            #trunk-ui {
                bottom: 60px; /* Align with collapsed roots panel */
                height: 150px; /* Shorter on mobile */
            }
            
            #trunk-ui.collapsed {
                bottom: 60px; /* Stay at same position when collapsed */
            }
        }
        
        #roots-content {
            padding: 25px 30px;
            color: white;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 100%;
        }
        
        #experience-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-height: none; /* No height limit, controlled by parent */
            overflow-y: visible;
            padding-right: 10px;
            position: relative;
            background: 
                /* Horizontal lines connecting rows */
                repeating-linear-gradient(
                    180deg,
                    transparent,
                    transparent 110px,
                    rgba(0, 255, 255, 0.2) 110px,
                    rgba(0, 255, 255, 0.2) 111px,
                    transparent 111px
                ),
                /* Vertical lines connecting columns */
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent calc(25% - 1px),
                    rgba(0, 255, 255, 0.2) calc(25% - 1px),
                    rgba(0, 255, 255, 0.2) calc(25%),
                    transparent calc(25%)
                ),
                /* Root-like branching pattern */
                radial-gradient(
                    ellipse at 50% 0%,
                    rgba(0, 255, 255, 0.05) 0%,
                    transparent 70%
                );
        }
        
        /* Responsive grid */
        @media (max-width: 1200px) {
            #experience-list {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            #experience-list {
                grid-template-columns: 1fr;
            }
            
            #legend {
                top: 10px;
                left: 10px;
                padding: 10px;
                font-size: 10px;
                max-width: 180px;
            }
            
            #legend h4 {
                font-size: 12px;
                margin-bottom: 8px;
                padding-bottom: 6px;
            }
            
            .legend-item {
                margin: 6px 0;
                gap: 8px;
            }
            
            .legend-icon.small {
                width: 10px;
                height: 10px;
            }
            
            .legend-icon.medium {
                width: 14px;
                height: 14px;
            }
            
            .legend-icon.large {
                width: 18px;
                height: 18px;
            }
            
            .legend-text {
                font-size: 10px;
            }
            
            .legend-divider {
                margin: 6px 0;
            }
            
            /* Reduce animations on mobile for better performance */
            #projects-toggle {
                animation: fruitSwing 3s ease-in-out infinite; /* Slower swing, no glow */
            }
            
            /* Legend toggle mobile adjustments */
            #legend-toggle-container {
                top: 15px;
                left: 15px;
            }
            
            #legend-toggle {
                width: 45px;
                height: 45px;
                font-size: 24px; /* Info icon size */
                animation: mapGlow 4s ease-in-out infinite; /* Slower glow */
                padding: 0; /* Remove padding for consistent sizing */
            }
            
            /* Legend positioned relative to button on mobile - start collapsed */
            #legend {
                position: fixed;
                top: 70px; /* Below button with more space */
                left: 15px; /* Align with button */
                max-width: calc(100vw - 30px); /* Full width minus margins */
                min-width: 250px; /* Maintain good size */
                max-height: calc(100vh - 150px); /* Don't go off bottom */
                padding: 15px; /* Keep full padding */
                overflow-y: auto; /* Allow scrolling if needed */
                right: auto;
                width: auto;
                transform: translateY(-10px); /* Start slightly higher */
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease, transform 0.3s ease;
            }
            
            /* Larger text on mobile for better readability */
            #legend h4 {
                font-size: 15px;
            }
            
            .legend-text {
                font-size: 13px;
            }
            
            .legend-item {
                margin: 10px 0; /* More spacing on mobile */
            }
            
            /* When legend is visible (not hidden) */
            #legend:not(.hidden) {
                opacity: 1;
                transform: translateY(0);
                pointer-events: auto;
            }
            
            /* Adjust if legend would go off right edge of screen */
            @media (max-width: 320px) {
                #legend {
                    max-width: calc(100vw - 30px); /* Account for margins */
                    min-width: auto;
                    left: 10px; /* Adjust for smaller screens */
                }
            }
            
            /* Scale skill detail card for mobile */
            #skill-detail {
                padding: 20px !important;
                max-width: 90% !important;
                width: 90% !important;
                max-height: 70vh !important;
                font-size: 14px;
            }
            
            #skill-detail h2 {
                font-size: 18px !important;
            }
            
            #skill-detail p {
                font-size: 13px !important;
                margin: 8px 0 !important;
            }
            
            #detail-breadcrumb {
                font-size: 12px !important;
            }
            
            #close-detail {
                font-size: 18px !important;
                width: 28px !important;
                height: 28px !important;
            }
            
            /* Optimize callout for mobile - top center positioning */
            #skill-callout {
                position: fixed;
                top: 120px; /* Position below legend and projects buttons */
                left: 50%; /* Center horizontally */
                transform: translateX(-50%) translateY(-20px); /* Center and start offset */
                max-width: 150px;
                padding: 8px 12px;
                font-size: 12px;
                border-radius: 20px;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
                width: auto;
            }
            
            #skill-callout.visible {
                transform: translateX(-50%) translateY(0); /* Slide down into view */
            }
            
            /* Override left/right classes on mobile */
            #skill-callout.left,
            #skill-callout.right {
                left: 50% !important;
                right: auto !important;
                top: 120px !important;
                transform: translateX(-50%) translateY(-20px) !important;
            }
            
            #skill-callout.visible.left,
            #skill-callout.visible.right {
                transform: translateX(-50%) translateY(0) !important;
            }
            
            /* Center class for mobile callouts */
            #skill-callout.center {
                left: 50% !important;
                top: 100px !important; /* Positioned where skill tree header appears */
                transform: translateX(-50%) translateY(-20px) !important;
            }
            
            #skill-callout.visible.center {
                transform: translateX(-50%) translateY(0) !important;
            }
            
            #skill-callout h3 {
                font-size: 14px;
                margin: 0;
                text-align: center;
            }
            
            /* Hide all paragraphs on mobile for title-only display */
            #skill-callout p {
                display: none;
            }
            
            /* Projects header mobile adjustments */
            #projects-header {
                max-width: 90%;
                padding: 15px;
            }
            
            #projects-links {
                gap: 10px;
            }
            
            .project-link {
                padding: 8px 15px;
                font-size: 12px;
            }
        }
        
        /* Tree Navigation Controls - Surrounding Node Design */
        #tree-navigation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px; /* Wider to account for card + buttons */
            height: 450px; /* Taller to account for card + buttons */
            z-index: 1001; /* Above detail panel (1000) so buttons are always accessible */
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none; /* Allow clicking through empty space */
        }
        
        #tree-navigation.visible {
            opacity: 1;
        }
        
        /* Arrow buttons - positioned around center */
        .nav-arrow-btn {
            position: absolute;
            background: rgba(76, 175, 80, 0.2);
            border: 3px solid rgba(76, 175, 80, 0.8);
            color: #4CAF50;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 32px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4);
            pointer-events: auto; /* Buttons are clickable */
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4);
            }
            50% {
                box-shadow: 0 4px 30px rgba(76, 175, 80, 0.7), 0 0 15px rgba(76, 175, 80, 0.5);
            }
        }
        
        .nav-arrow-btn:hover:not(:disabled) {
            background: rgba(76, 175, 80, 0.4);
            border-color: #4CAF50;
            box-shadow: 0 8px 40px rgba(76, 175, 80, 0.8);
            animation: none; /* Stop pulse on hover */
        }
        
        .nav-arrow-btn:active:not(:disabled) {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.6);
        }
        
        .nav-arrow-btn:disabled {
            opacity: 0;
            pointer-events: none;
        }
        
        .arrow-icon {
            font-size: 32px;
            line-height: 1;
            font-weight: bold;
        }
        
        /* Tooltip preview for navigation - always visible */
        .nav-arrow-btn::after {
            content: attr(data-target);
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: #4CAF50;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            opacity: 1;
            pointer-events: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(76, 175, 80, 0.6);
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.4);
            z-index: 1001;
        }
        
        /* Enhance label on hover */
        .nav-arrow-btn:hover:not(:disabled)::after {
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
        }
        
        /* Position tooltips based on button position - outside buttons */
        .nav-pos-up::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
        }
        
        .nav-pos-down::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
        }
        
        .nav-pos-left::after {
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 8px;
        }
        
        .nav-pos-right::after {
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px;
        }
        
        /* Position each arrow around the center - positioned outside the card */
        .nav-pos-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .nav-pos-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .nav-pos-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .nav-pos-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* Hover effects with enhanced pulse and glow - no transform changes */
        .nav-arrow-btn:hover:not(:disabled) {
            animation: pulse-glow-intense 0.6s ease-in-out infinite;
            background: rgba(76, 175, 80, 0.25);
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.8), 0 0 40px rgba(76, 175, 80, 0.5);
        }
        
        /* Intense pulse animation for hover - no scale/position changes */
        @keyframes pulse-glow-intense {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(76, 175, 80, 0.8), 0 0 40px rgba(76, 175, 80, 0.5);
            }
            50% { 
                box-shadow: 0 0 35px rgba(76, 175, 80, 1), 0 0 60px rgba(76, 175, 80, 0.7);
            }
        }
        
        /* Mobile adjustments for navigation - attach arrows to card */
        @media (max-width: 768px) {
            #tree-navigation {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80%; /* Reduced from 90% to leave room for left/right arrows */
                max-width: 350px; /* Reduced from 400px */
                height: 400px; /* Fixed height to properly position top/bottom arrows */
                pointer-events: none; /* Let clicks pass through container */
            }
            
            .nav-arrow-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
                border-width: 2px;
                pointer-events: auto; /* But buttons are clickable */
            }
            
            .arrow-icon {
                font-size: 20px;
            }
            
            /* Smaller labels on mobile */
            .nav-arrow-btn::after {
                font-size: 9px;
                padding: 3px 6px;
            }
            
            /* Position buttons just outside card edges with more clearance */
            .nav-pos-up {
                top: -10px; /* Position relative to container top */
                left: 50%;
                transform: translateX(-50%);
            }
            
            .nav-pos-down {
                bottom: -10px; /* Position relative to container bottom */
                left: 50%;
                transform: translateX(-50%);
                top: auto;
            }
            
            .nav-pos-left {
                left: -55px;
                top: 50%;
                transform: translateY(-50%);
            }
            
            .nav-pos-right {
                right: -55px;
                top: 50%;
                transform: translateY(-50%);
                left: auto;
            }
            
            /* Also reduce detail card width on mobile to match */
            #skill-detail {
                width: 80% !important;
                max-width: 350px !important;
            }
        }
        
        /* Reduce motion for users who prefer it */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            #projects-toggle {
                animation: none !important;
            }
            
            .seed {
                animation: none !important;
            }
        }
        
        /* Custom scrollbar */
        #experience-list::-webkit-scrollbar {
            width: 8px;
        }
        
        #experience-list::-webkit-scrollbar-track {
            background: rgba(0, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        #experience-list::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 4px;
        }
        
        #experience-list::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.7);
        }
        
        #roots-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.4);
        }
        
        #roots-header h2 {
            margin: 0;
            color: #00ffff;
            font-size: 22px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .experience-item {
            margin-bottom: 0;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.08), rgba(0, 255, 255, 0.18));
            border-left: 4px solid #00ffff;
            border-radius: 8px;
            transition: all 0.3s ease;
            height: fit-content; /* Cards are fully expanded */
            position: relative;
            z-index: 1;
            backdrop-filter: blur(5px);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.5s ease forwards;
        }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Icon and logo header row */
        .experience-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .experience-icon {
            font-size: 20px;
            opacity: 0.9;
            flex-shrink: 0;
        }
        
        .experience-logo {
            height: 22px;
            vertical-align: middle;
            flex-shrink: 0;
        }
        
        /* Stagger animation for items */
        .experience-item:nth-child(1) { animation-delay: 0.1s; }
        .experience-item:nth-child(2) { animation-delay: 0.15s; }
        .experience-item:nth-child(3) { animation-delay: 0.2s; }
        .experience-item:nth-child(4) { animation-delay: 0.25s; }
        .experience-item:nth-child(5) { animation-delay: 0.3s; }
        .experience-item:nth-child(6) { animation-delay: 0.35s; }
        .experience-item:nth-child(7) { animation-delay: 0.4s; }
        .experience-item:nth-child(8) { animation-delay: 0.45s; }
        .experience-item:nth-child(9) { animation-delay: 0.5s; }
        .experience-item:nth-child(10) { animation-delay: 0.55s; }
        .experience-item:nth-child(11) { animation-delay: 0.6s; }
        .experience-item:nth-child(12) { animation-delay: 0.65s; }
        
        .experience-item:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.3));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.4);
        }
        
        .experience-item h4 {
            margin: 0 0 6px 0;
            color: #00ffff;
            font-size: 15px;
            font-weight: 600;
            line-height: 1.3;
        }
        
        .experience-org {
            margin: 2px 0;
            font-size: 12px;
            color: #88ddff !important;
            font-weight: 500;
        }
        
        .experience-period {
            margin: 4px 0;
            font-size: 11px;
            color: #00ffff !important;
        }
        
        .experience-desc {
            margin: 6px 0 0 0;
            font-size: 12px;
            color: #aaa !important;
            line-height: 1.4;
        }
        
        .experience-item p {
            margin: 4px 0;
            font-size: 13px;
            color: #bbb;
        }
        
        .experience-item p strong {
            color: #00ffff;
        }
        
        /* Callout balloon */
        #skill-callout {
            position: fixed;
            top: 50%;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.95));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            width: 280px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            transform: translateY(-50%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease, transform 0.8s ease;
            z-index: 900;
        }
        
        #skill-callout.left {
            left: 40px;
            transform: translateY(-50%) translateX(-30px);
        }
        
        #skill-callout.right {
            right: 40px;
            transform: translateY(-50%) translateX(30px);
        }
        
        #skill-callout.visible.left {
            opacity: 1;
            transform: translateY(-50%) translateX(0);
        }
        
        #skill-callout.visible.right {
            opacity: 1;
            transform: translateY(-50%) translateX(0);
        }
        
        #skill-callout h3 {
            margin: 0 0 10px 0;
            color: #00ffff;
            font-size: 18px;
        }
        
        #skill-callout p {
            margin: 5px 0;
            font-size: 13px;
            color: #ccc;
        }
        
        #callout-line {
            position: fixed;
            z-index: 75;
            pointer-events: none;
        }
        
        /* Node throb animation */
        @keyframes nodeThrob {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        /* Legend/Key - dropdown from toggle button */
        #legend {
            position: absolute;
            top: 60px; /* Below the button */
            left: 0;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            font-size: 12px;
            color: #ccc;
            max-width: 250px;
            min-width: 220px; /* Ensure consistent width */
            pointer-events: none;
            z-index: 150;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.2);
        }
        
        #legend.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        #legend.expanded {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        /* Hidden state takes priority - allows toggling even when 'visible' class is present */
        #legend.hidden {
            opacity: 0 !important;
            transform: translateY(-10px) !important;
            pointer-events: none !important;
        }
        
        #legend h4 {
            margin: 0 0 10px 0;
            color: #00ffff;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            gap: 10px;
        }
        
        .legend-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .legend-icon.small {
            width: 12px;
            height: 12px;
        }
        
        .legend-icon.medium {
            width: 16px;
            height: 16px;
        }
        
        .legend-icon.large {
            width: 20px;
            height: 20px;
        }
        
        .legend-icon.robotics {
            background: #FF4500;
            box-shadow: 0 0 10px #FF4500;
        }
        
        .legend-icon.programming {
            background: #4169E1;
            box-shadow: 0 0 10px #4169E1;
        }
        
        .legend-icon.data {
            background: #32CD32;
            box-shadow: 0 0 10px #32CD32;
        }
        
        .legend-icon.mobile-robotics {
            background: #FF8C00;
            box-shadow: 0 0 10px #FF8C00;
        }
        
        .legend-icon.ai {
            background: #9370DB;
            box-shadow: 0 0 10px #9370DB;
        }
        
        .legend-icon.industrial {
            background: #DC143C;
            box-shadow: 0 0 10px #DC143C;
        }
        
        .legend-icon.design {
            background: #FF1493;
            box-shadow: 0 0 10px #FF1493;
        }
        
        .legend-icon.devops {
            background: #20B2AA;
            box-shadow: 0 0 10px #20B2AA;
        }
        
        .legend-text {
            flex: 1;
            line-height: 1.4;
            font-size: 13px;
        }
        
        .legend-divider {
            height: 1px;
            background: rgba(0, 255, 255, 0.2);
            margin: 10px 0;
        }
        
        /* Seed of Knowledge Loading Animation */
        /* By default the startup "Seed of Knowledge" intro animations are disabled.
           To enable them, add the class `enable-startup-animations` to the <body> element. */
        #seed-animation {
            /* hidden by default so the page starts up without the intro animation */
            display: none;
            opacity: 0;
            pointer-events: none;
        }

        /* When enabled, restore the full-screen seed animation container */
        body.enable-startup-animations #seed-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.8s ease;
        }
        
        #seed-animation.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .seed-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        .seed {
            position: absolute;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            /* animations are scoped to body.enable-startup-animations below */
        }

        /* Scoped animations: only run when body has enable-startup-animations */
        body.enable-startup-animations .seed {
            animation: seedFall 2s cubic-bezier(0.4, 0, 0.6, 1) forwards,
                       seedRotate 2s ease-in-out;
        }
        
        /* Watering can animation - comes from top (starts after seed falls + 1s delay) */
        .watering-can {
            position: absolute;
            top: -150px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            z-index: 10;
        }

        body.enable-startup-animations .watering-can {
            animation: wateringCanMove 2s ease-in-out 2s forwards; /* Start at 3s (2s seed + 1s delay) */
        }
        
        @keyframes wateringCanMove {
            0% {
                top: -150px;
                transform: translateX(-50%) rotate(0deg);
            }
            25% {
                top: 100px;
                transform: translateX(-50%) rotate(0deg);
            }
            40% {
                top: 100px;
                transform: translateX(-50%) rotate(-45deg);
            }
            70% {
                top: 100px;
                transform: translateX(-50%) rotate(-45deg);
            }
            85% {
                top: 100px;
                transform: translateX(-50%) rotate(0deg);
            }
            100% {
                top: -150px;
                transform: translateX(-50%) rotate(0deg);
            }
        }
        
        /* Rain animation - multiple drops (synced with watering can pouring at 40% of its animation) */
        .water-drops {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
        }

        body.enable-startup-animations .water-drops {
            animation: rainFadeIn 0.3s ease-in 3.8s forwards,  /* Start at 3.8s (3s can start + 0.8s to pour position at 40%) */
                       rainFadeOut 0.5s ease-out 5.4s forwards; /* Fade out when can returns upright at 85% (5.7s) */
        }
        
        .water-drop {
            position: absolute;
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, rgba(100, 180, 255, 0), rgba(100, 180, 255, 0.8), rgba(100, 180, 255, 0));
            animation: dropFall 0.6s linear infinite;
        }
        
        /* Create rain effect with multiple drops */
        .water-drop:nth-child(1) { left: 45%; animation-delay: 0s; }
        .water-drop:nth-child(2) { left: 48%; animation-delay: 0.1s; }
        .water-drop:nth-child(3) { left: 50%; animation-delay: 0.05s; }
        .water-drop:nth-child(4) { left: 52%; animation-delay: 0.15s; }
        .water-drop:nth-child(5) { left: 55%; animation-delay: 0.08s; }
        .water-drop:nth-child(6) { left: 46.5%; animation-delay: 0.2s; }
        .water-drop:nth-child(7) { left: 49%; animation-delay: 0.12s; }
        .water-drop:nth-child(8) { left: 51%; animation-delay: 0.18s; }
        .water-drop:nth-child(9) { left: 53.5%; animation-delay: 0.03s; }
        .water-drop:nth-child(10) { left: 47%; animation-delay: 0.22s; }
        
        @keyframes dropFall {
            0% {
                top: 180px;
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                top: calc(100vh - 370px);
                opacity: 0;
            }
        }
        
        @keyframes rainFadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        @keyframes rainFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes seedFall {
            0% {
                top: -100px;
                opacity: 0;
                transform: translateX(-50%) scale(1);
            }
            10% {
                opacity: 1;
            }
            50% {
                top: calc(100vh - 370px);
                transform: translateX(-50%) scale(1);
            }
            70% {
                top: calc(100vh - 370px);
                transform: translateX(-50%) scale(1.2);
            }
            100% {
                top: calc(100vh - 370px);
                transform: translateX(-50%) scale(4);
                opacity: 0;
            }
        }
        
        @keyframes seedRotate {
            0% {
                transform: translateX(-50%) rotate(0deg);
            }
            30% {
                transform: translateX(-50%) rotate(180deg);
            }
            50% {
                transform: translateX(-50%) rotate(360deg);
            }
            100% {
                transform: translateX(-50%) rotate(360deg);
            }
        }
        
        @keyframes seedGlow {
            0%, 100% {
                filter: drop-shadow(0 0 15px rgba(139, 90, 43, 0.8))
                        drop-shadow(0 0 25px rgba(139, 90, 43, 0.5));
            }
            50% {
                filter: drop-shadow(0 0 30px rgba(139, 90, 43, 1))
                        drop-shadow(0 0 50px rgba(205, 133, 63, 0.7));
            }
        }
        
        .seed svg {
            width: 100%;
            height: 100%;
            /* glow animation only when enabled */
        }

        body.enable-startup-animations .seed svg {
            animation: seedGlow 1.5s ease-in-out infinite;
        }
        
        /* Removed seed-impact pulse animation */
        
        .seed-text {
            position: absolute;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            color: #8B5A2B;
            font-size: 28px;
            font-weight: 700;
            text-align: center;
            opacity: 0;
            text-shadow: 0 0 10px rgba(139, 90, 43, 0.8);
        }

        body.enable-startup-animations .seed-text {
            animation: textFadeIn 0.8s ease-out 0.2s forwards,
                       textFadeOut 0.5s ease-out 0.9s forwards;
        }
        
        .watering-text {
            position: absolute;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 28px;
            font-weight: 700;
            text-align: center;
            opacity: 0;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        body.enable-startup-animations .watering-text {
            animation: textFadeIn 0.8s ease-out 3.8s forwards,  /* Sync with water drops at pour position */
                       textFadeOut 0.5s ease-out 5.4s forwards;   /* Fade out when pouring ends */
        }
        
        @keyframes textFadeIn {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        @keyframes textFadeOut {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Seed of Knowledge Loading Animation -->
    <div id="seed-animation">
        <div class="seed-container">
            <!-- Watering Can -->
            <div class="watering-can">
                <img src="https://uxwing.com/wp-content/themes/uxwing/download/agriculture-farming-gardening/watering-can-color-icon.svg" 
                     alt="Watering Can" 
                     style="width: 100%; height: 100%;">
            </div>
            
            <!-- Rain drops -->
            <div class="water-drops">
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
                <div class="water-drop"></div>
            </div>
            
            <div class="seed">
                <svg viewBox="0 0 100 140" xmlns="http://www.w3.org/2000/svg">
                    <!-- Seed body - brown acorn-like shape -->
                    <ellipse cx="50" cy="90" rx="35" ry="45" fill="#6B4423" stroke="#4a2f1a" stroke-width="2"/>
                    <ellipse cx="50" cy="85" rx="32" ry="40" fill="#8B5A2B"/>
                    
                    <!-- Seed cap - darker brown -->
                    <path d="M 20 70 Q 50 50, 80 70 L 75 85 Q 50 75, 25 85 Z" fill="#4a2f1a" stroke="#3a2010" stroke-width="2"/>
                    <ellipse cx="50" cy="72" rx="28" ry="15" fill="#5C3317"/>
                    
                    <!-- Seed texture lines -->
                    <line x1="50" y1="85" x2="50" y2="125" stroke="#4a2f1a" stroke-width="1.5" opacity="0.5"/>
                    <line x1="35" y1="95" x2="35" y2="120" stroke="#4a2f1a" stroke-width="1" opacity="0.4"/>
                    <line x1="65" y1="95" x2="65" y2="120" stroke="#4a2f1a" stroke-width="1" opacity="0.4"/>
                    
                    <!-- Highlight for depth -->
                    <ellipse cx="42" cy="85" rx="12" ry="20" fill="#A0714E" opacity="0.4"/>
                    
                    <!-- Cap texture -->
                    <path d="M 30 70 Q 50 65, 70 70" stroke="#3a2010" stroke-width="1.5" fill="none" opacity="0.6"/>
                    <path d="M 35 77 Q 50 73, 65 77" stroke="#3a2010" stroke-width="1" fill="none" opacity="0.4"/>
                </svg>
            </div>
            <div class="seed-text"> Seed of Knowledge </div>
            <div class="watering-text"> Growing Skills </div>
        </div>
    </div>
    
    <div id="canvas-container"></div>
    
    <!-- Legend Toggle (Collapsible) with integrated dropdown -->
    <div id="legend-toggle-container">
        <button id="legend-toggle" aria-label="Toggle skill tree key" title="Skill Tree Key"></button>
        
        <!-- Legend/Key as child of toggle button -->
        <div id="legend">
            <h4> Skill Tree Key</h4>
            <div class="legend-item">
                <div class="legend-icon small"></div>
                <div class="legend-text">Smaller nodes = Less experience</div>
            </div>
            <div class="legend-item">
                <div class="legend-icon large"></div>
                <div class="legend-text">Larger nodes = More experience</div>
            </div>
            <div class="legend-divider"></div>
            <div class="legend-item">
                <div class="legend-icon robotics"></div>
                <div class="legend-text">Robotics & Automation</div>
            </div>
            <div class="legend-item">
                <div class="legend-icon programming"></div>
                <div class="legend-text">Programming & Development</div>
            </div>
            <div class="legend-item">
                <div class="legend-icon data"></div>
                <div class="legend-text">Data & Analytics</div>
            </div>
            <div class="legend-item">
                <div class="legend-icon ai"></div>
                <div class="legend-text">AI & Machine Learning</div>
            </div>
            <div class="legend-item">
                <div class="legend-icon design"></div>
                <div class="legend-text">Design & Visualization</div>
            </div>
            <div class="legend-item">
                <div class="legend-icon devops"></div>
                <div class="legend-text">DevOps & Infrastructure</div>
            </div>
            <div class="legend-divider"></div>
            <div class="legend-text" style="font-size: 11px; font-style: italic; margin-top: 8px;">
                 Higher = More niche<br>
                 Lower = More foundational
            </div>
        </div>
    </div>
    
    <!-- Theme Toggle -->
    <button id="theme-toggle" aria-label="Toggle color theme" title="Switch Theme"></button>
    
    <!-- Resume Toggle Button -->
    <button id="resume-toggle" aria-label="Transform to resume" title="View as Resume"></button>
    
    <!-- Back to Tree Button -->
    <button id="back-to-tree"> Back to Tree</button>
    
    <!-- Recycle/Replant Button -->
    <button id="recycle-tree"> Recycle & Replant</button>
    
    <!-- Resume Container -->
    <div id="resume-container">
        <h1 style="text-align: center; color: #2c3e50; margin-bottom: 40px;">Resume</h1>
        <div id="resume-content"></div>
    </div>
    
    <!-- Projects Header (Collapsible) -->
    <button id="projects-toggle" aria-label="Toggle projects menu" title="Fruits of My Labor"></button>
    <div id="projects-header">
        <h2> Fruits of My Labor</h2>
        <div id="projects-links">
            <a href="https://github.com/TahriT" target="_blank" rel="noopener" class="project-link">
                <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                GitHub
            </a>
            <a href="https://www.linkedin.com/in/tahriturner" target="_blank" rel="noopener" class="project-link">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                </svg>
                LinkedIn
            </a>
            <a href="https://plantalytics.net" target="_blank" rel="noopener" class="project-link">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 6h-2.18c.11-.31.18-.65.18-1a2.996 2.996 0 00-5.5-1.65l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"/>
                </svg>
                PlantProjects
            </a>
            <a href="mailto:tahri.tech@protonmail.com" class="project-link">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                </svg>
                Email
            </a>
        </div>
    </div>
    
    <!-- Title Header -->
    <div id="header-title">
        <h1>Tahri's Skill Tree</h1>
        <p style="display: flex; align-items: center; justify-content: center; gap: 15px; flex-wrap: wrap; margin-top: 10px;">
            <span style="display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 24px; display: inline-block; animation: dragAnimation 2s ease-in-out infinite;"></span>
                <span>Drag to rotate</span>
            </span>
            <span style="opacity: 0.5;"></span>
            <span style="display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 24px; display: inline-block; animation: clickAnimation 1.5s ease-in-out infinite;"></span>
                <span>Click nodes to explore</span>
            </span>
        </p>
    </div>
    
    <style>
        @keyframes dragAnimation {
            0%, 100% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
        }
        
        @keyframes clickAnimation {
            0%, 100% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.3) translateY(-3px); }
        }
    </style>
    
    <div id="info">
        <h1> 3D Skill Tree</h1>
        <p>Drag to rotate  Click nodes to explore</p>
        <p id="skill-count">Loading skills...</p>
    </div>
    
    <!-- Trunk extension line -->
    <div id="trunk-ui"></div>
    
    <!-- Skill Callout Balloon -->
    <canvas id="callout-line"></canvas>
    <div id="skill-callout">
        <h3 id="callout-title"></h3>
        <p id="callout-category"></p>
        <p id="callout-level"></p>
        <p id="callout-experience"></p>
    </div>
    
    <!-- Roots/Experience Panel -->
    <div id="roots-panel">
        <button id="roots-toggle" aria-label="Toggle experience panel"></button>
        <div id="roots-content">
            <div id="roots-header">
                <h2 style="margin: 0; color: #66BB6A;">Tahri's Roots: Experience & Background</h2>
            </div>
            <div id="experience-list"></div>
        </div>
    </div>
    
    <!-- Skill Detail Panel -->
    <div id="skill-detail" style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 12px;
        border: 2px solid #00ffff;
        max-width: 500px;
        width: 90%;
        max-height: 60vh;
        overflow-y: auto;
        display: none;
        z-index: 1000;
        color: white;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    ">
        <button id="close-detail" style="
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 20px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            line-height: 1;
        ">&times;</button>
        <h2 id="detail-name" style="margin-top: 0; color: #00ffff;"></h2>
        <div id="detail-breadcrumb" style="color: #88ddff; font-size: 14px; margin-bottom: 15px; font-style: italic;"></div>
        <p id="detail-category" style="color: #aaa; margin-bottom: 10px;"></p>
        <p id="detail-level" style="margin-bottom: 5px;"></p>
        <p id="detail-experience" style="margin-bottom: 15px;"></p>
        <p id="detail-description" style="margin-top: 15px; line-height: 1.6;"></p>
        <div id="detail-additional" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(0, 255, 255, 0.3);"></div>
    </div>

    <!-- Tree Navigation Controls - Surrounding Current Node -->
    <div id="tree-navigation" style="display: none;">
        <!-- Up Arrow (Child - going up the tree visually) -->
        <button id="nav-up" class="nav-arrow-btn nav-pos-up" title="Navigate Up Tree" data-target="">
            <span class="arrow-icon"></span>
        </button>
        
        <!-- Down Arrow (Parent - going down to roots) -->
        <button id="nav-down" class="nav-arrow-btn nav-pos-down" title="Navigate Down Tree" data-target="">
            <span class="arrow-icon"></span>
        </button>
        
        <!-- Left Arrow (Previous Sibling/Child) -->
        <button id="nav-left" class="nav-arrow-btn nav-pos-left" title="Navigate Left" data-target="">
            <span class="arrow-icon"></span>
        </button>
        
        <!-- Right Arrow (Next Sibling/Child) -->
        <button id="nav-right" class="nav-arrow-btn nav-pos-right" title="Navigate Right" data-target="">
            <span class="arrow-icon"></span>
        </button>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- OrbitControls -->
    <script src="js/OrbitControls.js"></script>
    
    <script>
        // ===== SCENE SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1410); // Start with nature theme background
        
        const camera = new THREE.PerspectiveCamera(
            60, // Narrower FOV for better framing
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 20); // View centered on tree origin
        
        // Detect mobile device (user agent based, not just touch capability)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth < 768 && 'ontouchstart' in window);
        
        // Detect if device has touch capability (mobile OR desktop with touch)
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // Track first interaction to hide title
        let hasInteracted = false;
        
        // Function to hide title on first interaction
        function hideHeaderTitle() {
            if (!hasInteracted) {
                hasInteracted = true;
                const headerTitle = document.getElementById('header-title');
                headerTitle.style.transition = 'opacity 1s ease-out, transform 1s ease-out';
                headerTitle.style.opacity = '0';
                headerTitle.style.transform = 'translateX(-50%) translateY(-20px)';
                
                // Remove from DOM after fade completes
                setTimeout(() => {
                    headerTitle.style.display = 'none';
                }, 1000);
            }
        }
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile, // Disable antialiasing on mobile for performance
            powerPreference: isMobile ? 'low-power' : 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2)); // Limit pixel ratio on mobile
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Camera controls - orbit around center of visible area
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0); // Look at origin where tree starts
        controls.enableDamping = true;
        controls.dampingFactor = 0.15;
        
        // Zoom/Dolly settings (enable scrolling in both directions)
        controls.enableZoom = true; // Enable mouse wheel zoom
        controls.zoomSpeed = 1.0;
        controls.minDistance = 5; // Closest zoom (scroll in)
        controls.maxDistance = 35; // Farthest zoom (scroll out)
        
        // Vertical rotation limits
        controls.minPolarAngle = Math.PI / 4; // Lower vertical limit (45 degrees)
        controls.maxPolarAngle = Math.PI / 2; // Upper vertical limit (90 degrees)
        
        // Rotation speed (slower on mobile for better control)
        controls.rotateSpeed = isMobile ? 0.3 : 0.5;
        
        // Touch settings for mobile
        if (isMobile) {
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
        }
        
        controls.update();
        
        // Add interaction event listeners for hiding title
        const canvas = renderer.domElement;
        
        // Mouse events
        canvas.addEventListener('mousedown', hideHeaderTitle);
        canvas.addEventListener('mousemove', function(e) {
            // Only hide on mousemove if mouse button is pressed (dragging)
            if (e.buttons > 0) {
                hideHeaderTitle();
            }
        });
        canvas.addEventListener('wheel', hideHeaderTitle);
        
        // Touch events (works on both mobile and desktop touch screens)
        if (hasTouch) {
            canvas.addEventListener('touchstart', hideHeaderTitle);
            canvas.addEventListener('touchmove', hideHeaderTitle);
        }
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        // ===== 3D TREE BUILDER =====
        class SkillTree3D {
            constructor() {
                this.tree = new THREE.Group();
                this.branchRadius = 0.1;
                this.branchColor = 0x4a3728;
                this.nodeSize = 0.2;
                this.currentTheme = 'nature'; // 'tech' or 'nature' - default to nature
                
                // Tech theme colors (current neon/cyber look)
                this.techCategoryColors = {
                    'Robotics & Automation': 0xFF4500,      // Orange-Red
                    'Programming & Development': 0x4169E1,  // Royal Blue
                    'Data & Analytics': 0x32CD32,           // Lime Green
                    'Mobile Robotics': 0xFF8C00,            // Dark Orange
                    'AI & Machine Learning': 0x9370DB,      // Medium Purple
                    'Industrial Systems': 0xDC143C,         // Crimson
                    'Design & Visualization': 0xFF1493,     // Deep Pink
                    'DevOps & Infrastructure': 0x20B2AA     // Light Sea Green
                };
                
                // Nature theme colors (tree-like earthy tones)
                this.natureCategoryColors = {
                    'Robotics & Automation': 0x4B8B3B,      // Forest Green
                    'Programming & Development': 0x2E7D32,  // Dark Green
                    'Data & Analytics': 0x66BB6A,           // Light Green
                    'Mobile Robotics': 0x558B2F,            // Olive Green
                    'AI & Machine Learning': 0x00C853,      // Bright Green
                    'Industrial Systems': 0x388E3C,         // Medium Green
                    'Design & Visualization': 0x81C784,     // Pale Green
                    'DevOps & Infrastructure': 0x43A047     // Grass Green
                };
                
                // Start with nature theme as default
                this.categoryColors = this.natureCategoryColors;
                
                this.categoryIndex = 0; // Track which category we're in
                this.connectionLines = []; // Store connections for trace animation
                this.traceMaterials = []; // Store materials for animation
                
                // Animation system
                this.animationQueue = []; // Queue of objects to animate in
                this.isAnimating = false;
                this.animationProgress = 0;
            }
            
            // Count skills in a branch to determine trunk height
            countBranchSkills(node) {
                let count = node.type !== 'root' ? 1 : 0;
                if (node.children) {
                    node.children.forEach(child => {
                        count += this.countBranchSkills(child);
                    });
                }
                return count;
            }
            
            // Adjust color brightness based on depth (darker = shallow, brighter = deep)
            adjustColorBrightness(hexColor, depth) {
                const r = (hexColor >> 16) & 0xFF;
                const g = (hexColor >> 8) & 0xFF;
                const b = hexColor & 0xFF;
                
                // Start darker (0.4), get brighter with depth (up to 1.2)
                const brightness = 0.4 + (depth * 0.15);
                
                const newR = Math.min(255, Math.floor(r * brightness));
                const newG = Math.min(255, Math.floor(g * brightness));
                const newB = Math.min(255, Math.floor(b * brightness));
                
                return (newR << 16) | (newG << 8) | newB;
            }
            
            // Get color for a node based on its category and depth
            getNodeColor(skillData, level, categoryName) {
                // If skill has explicit color in JSON, use it directly (no brightness adjustment)
                if (skillData.color) {
                    const baseColor = typeof skillData.color === 'string' 
                        ? parseInt(skillData.color.replace('#', '0x'), 16)
                        : skillData.color;
                    return baseColor; // No brightness adjustment
                }
                
                // Use category color directly (no depth-based brightness)
                const baseColor = this.categoryColors[categoryName] || 0x888888;
                return baseColor; // No brightness adjustment
            }
            
            // Switch between tech and nature themes
            switchTheme(themeName) {
                this.currentTheme = themeName;
                
                // Update color palette
                if (themeName === 'nature') {
                    this.categoryColors = this.natureCategoryColors;
                } else {
                    this.categoryColors = this.techCategoryColors;
                }
                
                // Update all node materials
                this.tree.traverse((child) => {
                    if (child.userData && child.userData.isSkillNode && child.material) {
                        const categoryName = child.userData.category;
                        const skillData = child.userData.skillData;
                        const level = child.userData.level;
                        
                        // Recalculate color with new palette
                        const newColor = this.getNodeColor(skillData, 0, categoryName);
                        child.material.color.setHex(newColor);
                        child.material.emissive.setHex(newColor);
                    }
                    
                    // Update connection lines (branches)
                    if (child.userData && child.userData.isConnection && child.material) {
                        if (themeName === 'nature') {
                            // Brown branches for nature theme
                            const brownColor = 0x654321; // Dark brown
                            child.material.color.setHex(brownColor);
                            child.material.emissive.setHex(brownColor);
                            child.material.emissiveIntensity = 0.3; // Subtle glow
                        } else {
                            // Colorful branches for tech theme
                            const categoryName = child.userData.category;
                            const level = child.userData.level || 0;
                            
                            const baseColor = this.categoryColors[categoryName] || 0x00ffff;
                            const brightColor = this.adjustColorBrightness(baseColor, level);
                            
                            child.material.color.setHex(brightColor);
                            child.material.emissive.setHex(brightColor);
                            child.material.emissiveIntensity = 0.6;
                        }
                    }
                });
                
                // Update scene background
                if (themeName === 'nature') {
                    scene.background.setHex(0x1a1410); // Earthy dark brown
                } else {
                    scene.background.setHex(0x0a0a0a); // Deep black
                }
            }
            
            async build() {
                // Load skills.json
                console.log(' Loading skills.json...');
                const response = await fetch('data/skills.json');
                const data = await response.json();
                console.log(' Loaded data:', data);
                
                const root = data.skills;
                console.log(' Root node:', root);
                
                // Update UI
                const count = this.countSkills(root);
                document.getElementById('skill-count').textContent = `${count} skills loaded`;
                console.log(` Total skills: ${count}`);
                
                // Build tree from root starting lower to be visible above experience panel
                const startPos = new THREE.Vector3(0, -14, 0); // Start much lower
                const upDir = new THREE.Vector3(0, 1, 0);
                
                // Scale to fit approximately half screen height
                const treeHeight = 8; // Target height
                this.buildBranch(root, startPos, upDir, 0, treeHeight, null);
                
                scene.add(this.tree);
                console.log(' Tree built successfully!');
                
                // Don't start animation yet - wait for roots panel to load
                
                // Generate experience data for roots panel (await since it's now async)
                await this.generateExperiencePanel();
            }
            
            async generateExperiencePanel() {
                const experienceList = document.getElementById('experience-list');
                experienceList.innerHTML = '';

                try {
                    // Load experience data from JSON
                    const response = await fetch('data/experience.json');
                    const data = await response.json();
                    const experiences = data.categories;

                    // Generate HTML for each category
                    experiences.forEach(category => {
                        category.items.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'experience-item';
                            itemDiv.setAttribute('data-category', category.category);
                            
                            let logoHtml = '';
                            if (item.logoUrl) {
                                logoHtml = `<img src="${item.logoUrl}" alt="${item.organization} logo" class="experience-logo">`;
                            }
                            
                            itemDiv.innerHTML = `
                                <div class="experience-header">
                                    <div class="experience-icon">${category.icon}</div>
                                    ${logoHtml}
                                </div>
                                <h4>${item.title}</h4>
                                <p class="experience-org">${item.organization}</p>
                                <p class="experience-period"><strong>${item.period}</strong></p>
                                ${item.location ? `<p class="experience-location">${item.location}</p>` : ''}
                                <p class="experience-desc">${item.description.replace(/\n/g, '<br>')}</p>
                            `;
                            experienceList.appendChild(itemDiv);
                        });
                    });
                } catch (error) {
                    console.error('Error loading experience data:', error);
                    experienceList.innerHTML = '<p style="color: #ff6b6b; padding: 20px;">Failed to load experience data.</p>';
                }
            }
            
            buildBranch(node, startPos, direction, level, length, categoryName, parentChain = []) {
                // Track category name for color grouping
                let currentCategory = categoryName;
                if (node.type === 'category') {
                    currentCategory = node.name;
                }
                
                // Build parent chain for breadcrumb navigation
                const newParentChain = [...parentChain];
                if (node.type !== 'root' && node.name) {
                    newParentChain.push(node.name);
                }
                
                // Add vertical trunk segment before branching (except for root)
                let branchStartPos = startPos.clone();
                
                if (node.type !== 'root') {
                    // Scale trunk height based on number of skills in this branch
                    const skillCount = this.countBranchSkills(node);
                    const heightMultiplier = 0.5 + (Math.min(skillCount, 20) / 20) * 1.0; // 0.5 to 1.5 (increased from 0.3-1.0)
                    const trunkHeight = length * 0.8 * heightMultiplier; // Increased from 0.5 to 0.8
                    
                    const trunkEnd = startPos.clone().add(new THREE.Vector3(0, trunkHeight, 0));
                    
                    const trunk = this.createBranch(startPos, trunkEnd, level, currentCategory);
                    trunk.visible = false; // Start hidden for animation
                    trunk.userData.animationDelay = this.animationQueue.length * 0.02; // Stagger timing
                    this.animationQueue.push(trunk);
                    this.tree.add(trunk);
                    
                    // Update start position for actual branch
                    branchStartPos = trunkEnd;
                }
                
                // Calculate end position from trunk end
                const endPos = branchStartPos.clone().add(
                    direction.clone().multiplyScalar(length)
                );
                
                // Create branch and node (skip for root container)
                if (node.type !== 'root') {
                    // Branch cylinder from trunk to end
                    const branch = this.createBranch(branchStartPos, endPos, level, currentCategory);
                    branch.visible = false; // Start hidden for animation
                    branch.userData.animationDelay = this.animationQueue.length * 0.02; // Stagger timing
                    this.animationQueue.push(branch);
                    this.tree.add(branch);
                    
                    // Node sphere at end
                    const nodeMesh = this.createNode(node, endPos, level, currentCategory, newParentChain);
                    nodeMesh.visible = false; // Start hidden for animation
                    nodeMesh.userData.animationDelay = this.animationQueue.length * 0.02;
                    nodeMesh.userData.targetScale = nodeMesh.scale.clone(); // Store target scale
                    nodeMesh.scale.set(0, 0, 0); // Start at 0 scale
                    this.animationQueue.push(nodeMesh);
                    this.tree.add(nodeMesh);
                }
                
                // Recursively build children from end position
                if (node.children && node.children.length > 0) {
                    const childCount = node.children.length;
                    const baseLength = length * 0.7;
                    const spreadAngle = Math.PI / 2.2; // ~82 degrees - more horizontal spread
                    
                    node.children.forEach((child, i) => {
                        const newDir = this.getBranchDirection(
                            direction, 
                            childCount, 
                            i, 
                            spreadAngle
                        );
                        
                        // Consistent length (remove random variation)
                        const newLength = baseLength;
                        
                        this.buildBranch(
                            child, 
                            endPos.clone(), 
                            newDir, 
                            level + 1, 
                            newLength,
                            currentCategory,
                            newParentChain
                        );
                    });
                }
            }
            
            getBranchDirection(parentDir, childCount, index, spreadAngle) {
                if (childCount === 1) {
                    // Single child - continue mostly upward
                    return new THREE.Vector3(0, 1, 0);
                }
                
                // Multiple children - radial spread (NO random variation)
                const baseAngle = (index / childCount) * Math.PI * 2;
                
                // Consistent spread angle
                const dir = new THREE.Vector3(
                    Math.cos(baseAngle) * Math.sin(spreadAngle),
                    Math.cos(spreadAngle), // This controls vertical component
                    Math.sin(baseAngle) * Math.sin(spreadAngle)
                );
                
                return dir.normalize();
            }
            
            createBranch(start, end, level, categoryName) {
                const direction = new THREE.Vector3().subVectors(end, start);
                const length = direction.length();
                
                // Get category color for this connection
                const baseColor = this.categoryColors[categoryName] || 0x00ffff;
                const brightColor = this.adjustColorBrightness(baseColor, level);
                
                // Create digital connection line
                const curve = new THREE.LineCurve3(start, end);
                const tubeRadius = 0.02 + (0.01 / (level + 1)); // Thinner at deeper levels
                const tubeGeometry = new THREE.TubeGeometry(curve, 8, tubeRadius, 6, false);
                
                // Main glowing tube
                const material = new THREE.MeshPhongMaterial({
                    color: brightColor,
                    emissive: brightColor,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100
                });
                
                const mesh = new THREE.Mesh(tubeGeometry, material);
                mesh.userData.isConnection = true;
                mesh.userData.level = level;
                mesh.userData.category = categoryName; // Store category for theme switching
                mesh.userData.startPos = start.clone();
                mesh.userData.endPos = end.clone();
                mesh.userData.branchLength = length;
                this.connectionLines.push(mesh);
                
                // Add animated trace line - thinner line that pulses along the connection
                const traceMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                
                const traceGeometry = new THREE.TubeGeometry(curve, 8, tubeRadius * 1.5, 6, false);
                const traceMesh = new THREE.Mesh(traceGeometry, traceMaterial);
                traceMesh.userData.isTrace = true;
                traceMesh.userData.level = level;
                traceMesh.userData.start = start.clone();
                traceMesh.userData.end = end.clone();
                
                this.traceMaterials.push(traceMaterial);
                this.tree.add(traceMesh);
                
                return mesh;
            }
            
            createNode(skillData, position, level, categoryName, parentChain = []) {
                // Base size decreases with depth
                let baseSize = this.nodeSize * Math.pow(0.85, level);
                
                // Scale based on years of experience
                let experienceMultiplier = 1.0;
                if (skillData.yearsExp) {
                    // More experience = bigger node (0.5x to 2x scale)
                    experienceMultiplier = 0.5 + (skillData.yearsExp / 10) * 1.5;
                    experienceMultiplier = Math.min(experienceMultiplier, 2.0); // Cap at 2x
                }
                
                const size = baseSize * experienceMultiplier;
                
                // Get color based on category and depth (darker to brighter)
                const color = this.getNodeColor(skillData, level, categoryName);
                
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3 + (experienceMultiplier * 0.2) // More glow for more experience
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                
                // Store metadata for interaction
                mesh.userData = {
                    skillData: skillData,
                    yearsExp: skillData.yearsExp || 0,
                    level: skillData.level || 'Beginner',
                    category: categoryName,
                    parentChain: parentChain,
                    isSkillNode: true,
                    position: position.clone(),
                    baseEmissive: 0.3 + (experienceMultiplier * 0.2),
                    pathToRoot: [] // Will be populated with connections
                };
                
                // Add text label
                this.addLabel(skillData.name, mesh, size);
                
                return mesh;
            }
            
            addLabel(text, parent, size) {
                // Text labels disabled for cleaner visual
                return;
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, 256, 80);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                
                const sprite = new THREE.Sprite(spriteMat);
                sprite.scale.set(size * 10, size * 2.5, 1);
                sprite.position.y = size * 1.8;
                
                parent.add(sprite);
            }
            
            countSkills(node) {
                let count = node.type !== 'root' ? 1 : 0;
                if (node.children) {
                    node.children.forEach(child => {
                        count += this.countSkills(child);
                    });
                }
                return count;
            }
            
            // Start the build animation
            startBuildAnimation() {
                this.isAnimating = true;
                this.animationProgress = 0;
                console.log(` Starting animation for ${this.animationQueue.length} objects`);
            }
            
            // Update build animation
            updateBuildAnimation(deltaTime) {
                if (!this.isAnimating) return;
                
                this.animationProgress += deltaTime * 2; // Animation speed multiplier
                
                let allComplete = true;
                
                this.animationQueue.forEach((object) => {
                    const delay = object.userData.animationDelay || 0;
                    const progress = Math.max(0, Math.min(1, (this.animationProgress - delay) / 0.4)); // 0.4s per object
                    
                    if (progress < 1) {
                        allComplete = false;
                    }
                    
                    // Smooth easing function (ease-out cubic for natural growth)
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    if (object.userData.isSkillNode) {
                        // Animate node scale - growing from center
                        if (object.userData.targetScale && progress > 0) {
                            object.visible = true;
                            object.scale.lerpVectors(
                                new THREE.Vector3(0, 0, 0),
                                object.userData.targetScale,
                                eased
                            );
                        }
                    } else if (object.userData.isConnection) {
                        // Animate branch growing along its length
                        if (progress > 0) {
                            object.visible = true;
                            
                            // Scale along the branch direction (Y-axis of local space)
                            const direction = new THREE.Vector3()
                                .subVectors(object.userData.endPos, object.userData.startPos)
                                .normalize();
                            
                            // Determine which axis is most aligned with branch direction
                            const absX = Math.abs(direction.x);
                            const absY = Math.abs(direction.y);
                            const absZ = Math.abs(direction.z);
                            
                            if (absY > absX && absY > absZ) {
                                // Vertical branch - scale Y
                                object.scale.set(1, eased, 1);
                            } else if (absX > absZ) {
                                // More horizontal (X) - scale X
                                object.scale.set(eased, 1, 1);
                            } else {
                                // More horizontal (Z) - scale Z
                                object.scale.set(1, 1, eased);
                            }
                            
                            // Also fade in opacity
                            object.material.opacity = eased * 0.8; // Target opacity
                        }
                    }
                });
                
                if (allComplete) {
                    this.isAnimating = false;
                    console.log(' Build animation complete!');
                    // Enable callouts after animation completes
                    window.treeAnimationComplete = true;
                }
            }
            
            // Animate connections - pulsing glow effect and lightning trace
            update(time) {
                this.tree.traverse((object) => {
                    if (object.userData.isConnection) {
                        // Pulse the emissive intensity
                        const pulse = Math.sin(time * 2 + object.userData.level) * 0.3 + 0.5;
                        object.material.emissiveIntensity = pulse;
                    }
                    
                    if (object.userData.isTrace) {
                        // Lightning trace (only visible when node is selected)
                        if (this.selectedNode && object.userData.isActive) {
                            // Traveling orb effect
                            const traceSpeed = 2;
                            const progress = (time * traceSpeed) % 1;
                            
                            // Bright flash that travels along the path
                            const distance = Math.abs(progress - 0.5) * 2; // 0 at center, 1 at edges
                            object.material.opacity = 1 - distance;
                        } else {
                            object.material.opacity = 0;
                        }
                    }
                    
                    // Reset nodes to default state
                    if (object.userData.isSkillNode && !object.userData.isHovered) {
                        object.material.emissiveIntensity = object.userData.baseEmissive;
                    }
                });
            }
            
            // Highlight a skill and its path to root
            selectSkill(node) {
                this.selectedNode = node;
                
                // Collapse the experience panel and trunk when selecting a node
                const rootsPanel = document.getElementById('roots-panel');
                const trunkUI = document.getElementById('trunk-ui');
                
                if (node) {
                    rootsPanel.classList.add('collapsed');
                    trunkUI.classList.add('collapsed');
                } else {
                    // Re-expand when deselecting
                    rootsPanel.classList.remove('collapsed');
                    trunkUI.classList.remove('collapsed');
                }
                
                // Reset all traces
                this.tree.traverse((object) => {
                    if (object.userData.isTrace) {
                        object.userData.isActive = false;
                    }
                });
                
                // Activate path to root
                if (node && node.userData.pathToRoot) {
                    node.userData.pathToRoot.forEach(connection => {
                        connection.userData.isActive = true;
                    });
                    
                    // Brighten the selected node
                    node.material.emissiveIntensity = 1.5;
                }
            }
            
            // Get all skill nodes for raycasting
            getSkillNodes() {
                const nodes = [];
                this.tree.traverse((object) => {
                    if (object.userData.isSkillNode) {
                        nodes.push(object);
                    }
                });
                return nodes;
            }
        }
        
        // ===== LOAD PROJECTS =====
        async function loadProjects() {
            try {
                const response = await fetch('data/projects.json');
                const data = await response.json();
                const projectsLinks = document.getElementById('projects-links');
                projectsLinks.innerHTML = '';
                
                data.projects.forEach(project => {
                    const link = document.createElement('a');
                    link.href = project.url;
                    link.target = '_blank';
                    link.rel = 'noopener';
                    link.className = 'project-link';
                    link.innerHTML = `
                        <svg viewBox="${project.viewBox}" xmlns="http://www.w3.org/2000/svg">
                            ${project.svg}
                        </svg>
                        ${project.name}
                    `;
                    projectsLinks.appendChild(link);
                });
            } catch (error) {
                console.error('Error loading projects:', error);
            }
        }
        
        // Load projects on page load
        loadProjects();
        
        // ===== BUILD & ANIMATE =====
        const skillTree = new SkillTree3D();
        const seedAnimation = document.getElementById('seed-animation');
        
        // Start building tree (hidden initially)
        skillTree.build();
        
        // Seed animation sequence (new timing: 2s seed + 1s + 3s can + 0.5s + 0.75s rain + 1.7s rain duration)
        setTimeout(() => {
            // Hide seed animation after all animations complete
            seedAnimation.classList.add('hidden');
            
            // Show header title after seed animation
            document.getElementById('header-title').classList.add('visible');
            
            // Show experience panel and trunk after seed disappears
            setTimeout(() => {
                document.getElementById('roots-panel').classList.add('loaded');
                document.getElementById('trunk-ui').classList.add('loaded');
                
                // Show legend automatically on desktop only, hide on mobile
                const legend = document.getElementById('legend');
                const legendToggle = document.getElementById('legend-toggle');
                
                if (!isMobile) {
                    legend.classList.add('visible');
                } else {
                    // Start collapsed on mobile with info icon
                    legend.classList.add('hidden');
                    legendToggle.textContent = '';
                }
                
                // Start tree build animation after roots panel is visible
                setTimeout(() => {
                    skillTree.startBuildAnimation();
                }, 500); // Additional 0.5s delay after panel loads
            }, 800); // Wait for seed animation fade out
        }, 6500); // Total: 2s seed + 1s + 3s can + 0.5s + 0.75s + 1.7s rain duration = ~8.95s, using 6.5s for better UX
        
        // ===== ROOTS PANEL TOGGLE (Mobile) =====
        const rootsToggle = document.getElementById('roots-toggle');
        const rootsPanel = document.getElementById('roots-panel');
        const trunkUI = document.getElementById('trunk-ui');
        
        // Function to update trunk-ui position based on roots-panel height
        function updateTrunkPosition() {
            if (rootsPanel && trunkUI) {
                const rootsHeight = rootsPanel.offsetHeight;
                trunkUI.style.bottom = `${rootsHeight}px`;
            }
        }
        
        // Update trunk position on hover
        rootsPanel.addEventListener('mouseenter', () => {
            setTimeout(updateTrunkPosition, 50); // Small delay for transition
        });
        
        rootsPanel.addEventListener('mouseleave', () => {
            setTimeout(updateTrunkPosition, 50);
        });
        
        // Also update on window resize
        window.addEventListener('resize', updateTrunkPosition);
        
        // Initial update after roots panel loads
        setTimeout(updateTrunkPosition, 1000);
        
        rootsToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            rootsPanel.classList.toggle('expanded');
            rootsToggle.textContent = rootsPanel.classList.contains('expanded') ? '' : '';
            setTimeout(updateTrunkPosition, 50);
        });
        
        // ===== LEGEND TOGGLE =====
        const legendToggleContainer = document.getElementById('legend-toggle-container');
        const legendToggle = document.getElementById('legend-toggle');
        const legend = document.getElementById('legend');
        
        legendToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // Toggle the hidden class to show/hide legend
            if (legend.classList.contains('hidden')) {
                // Show the legend
                legend.classList.remove('hidden');
                legendToggle.classList.add('expanded');
            } else {
                // Hide the legend
                legend.classList.add('hidden');
                legendToggle.classList.remove('expanded');
            }
        });
        
        // Close legend when clicking outside the container
        document.addEventListener('click', (e) => {
            if (!legendToggleContainer.contains(e.target)) {
                if (!legend.classList.contains('hidden')) {
                    legend.classList.add('hidden');
                    legendToggle.classList.remove('expanded');
                }
            }
        });
        
        // ===== PROJECTS HEADER TOGGLE =====
        const projectsToggle = document.getElementById('projects-toggle');
        const projectsHeader = document.getElementById('projects-header');
        
        projectsToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            projectsHeader.classList.toggle('expanded');
            projectsToggle.classList.toggle('expanded');
        });
        
        // Close projects header when clicking outside
        document.addEventListener('click', (e) => {
            if (!projectsHeader.contains(e.target) && !projectsToggle.contains(e.target)) {
                projectsHeader.classList.remove('expanded');
                projectsToggle.classList.remove('expanded');
            }
        });
        
        // ===== THEME TOGGLE =====
        const themeToggle = document.getElementById('theme-toggle');
        let currentTheme = 'nature'; // Start with nature theme as default
        document.body.classList.add('nature-theme'); // Apply nature theme styles on load
        
        themeToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // Toggle theme
            if (currentTheme === 'tech') {
                // Switch to nature theme
                currentTheme = 'nature';
                themeToggle.textContent = ''; // Tree emoji for nature theme
                document.body.classList.add('nature-theme');
                skillTree.switchTheme('nature');
            } else {
                // Switch back to tech theme
                currentTheme = 'tech';
                themeToggle.textContent = ''; // Digital/tech emoji
                document.body.classList.remove('nature-theme');
                skillTree.switchTheme('tech');
            }
        });
        
        // ===== CALLOUT BALLOON SYSTEM =====
        const calloutBalloon = document.getElementById('skill-callout');
        const calloutLine = document.getElementById('callout-line');
        const calloutCtx = calloutLine.getContext('2d');
        let currentCalloutNode = null;
        let calloutInterval = null;
        let isCalloutFading = false;
        let calloutShowTime = null; // Track when callout was shown
        let lineDrawProgress = 0; // Track line drawing animation
        let lineFadeProgress = 1; // Track line fade out (1 = fully visible, 0 = invisible)
        let isLineFading = false; // Track if line is fading out
        const CALLOUT_DISPLAY_DURATION = isMobile ? 4000 : 3000; // Longer display on mobile
        const LINE_FADE_DURATION = 800; // Line fade out duration
        let isHoverCallout = false; // Track if current callout is from hover
        let lastInteractionTime = Date.now(); // Track last user interaction
        let autoResumeTimeout = null; // Timeout for auto-resuming callouts
        window.treeAnimationComplete = false; // Track when tree animation is done
        let calloutTimeouts = []; // Track all active callout timeouts
        
        // Disable auto-callouts on mobile (only show on hover/tap)
        let enableAutoCallouts = !isMobile; // Changed from const to let
        
        // Setup canvas for line drawing
        calloutLine.width = window.innerWidth;
        calloutLine.height = window.innerHeight;
        calloutLine.style.width = '100%';
        calloutLine.style.height = '100%';
        
        function showCalloutForNode(node, isFromHover = false) {
            // Don't show callouts until tree animation is complete
            if (!window.treeAnimationComplete) return;
            
            // Don't show callouts during resume transformation
            if (isTransformingToResume || isResumeMode) return;
            
            // If already showing a callout, prevent race condition
            if (currentCalloutNode && currentCalloutNode !== node) {
                // Clear all pending timeouts for the previous callout
                calloutTimeouts.forEach(timeout => clearTimeout(timeout));
                calloutTimeouts = [];
                // Reset the previous callout state immediately
                currentCalloutNode = null;
                isCalloutFading = false;
                isLineFading = false;
                calloutBalloon.classList.remove('visible');
                calloutCtx.clearRect(0, 0, calloutLine.width, calloutLine.height);
            }
            
            // Get node position
            const worldPos = new THREE.Vector3();
            node.getWorldPosition(worldPos);
            
            const screenPos = worldPos.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
            
            // Check if node is visible
            if (screenPos.z > 1 || x < 0 || x > window.innerWidth || y < 0 || y > window.innerHeight) {
                return; // Node not visible
            }
            
            // Determine left or right side
            const isLeft = x < window.innerWidth / 2;
            const className = isLeft ? 'left' : 'right';
            
            const data = node.userData.skillData;
            
            // Update callout content
            document.getElementById('callout-title').textContent = data.name;
            document.getElementById('callout-category').innerHTML = 
                `<strong>Category:</strong> ${node.userData.category || 'N/A'}`;
            document.getElementById('callout-level').innerHTML = 
                `<strong>Level:</strong> ${data.level || 'N/A'}`;
            document.getElementById('callout-experience').innerHTML = 
                `<strong>Experience:</strong> ${data.yearsExp || 0} years`;
            
            // Position callout (start offset for fade-in animation)
            calloutBalloon.className = className;
            
            // Reset and start line drawing animation
            lineDrawProgress = 0;
            lineFadeProgress = 1;
            isLineFading = false;
            calloutShowTime = Date.now();
            isHoverCallout = isFromHover;
            
            // Fade in after a brief delay
            const fadeTimeout = setTimeout(() => {
                calloutBalloon.classList.add('visible');
            }, 50);
            calloutTimeouts.push(fadeTimeout);
            
            currentCalloutNode = node;
            
            // Only auto-hide if not from hover
            if (!isFromHover) {
                // Start line fade 500ms before balloon fade
                const lineFadeTimeout = setTimeout(() => {
                    isLineFading = true;
                    lineFadeProgress = 1;
                }, CALLOUT_DISPLAY_DURATION - LINE_FADE_DURATION - 500);
                calloutTimeouts.push(lineFadeTimeout);
                
                // Hide balloon after duration
                const hideTimeout = setTimeout(() => {
                    hideCallout(true); // true = immediately show next one
                }, CALLOUT_DISPLAY_DURATION);
                calloutTimeouts.push(hideTimeout);
            }
        }
        
        function showRandomCallout() {
            // Don't show if user is interacting, if we're already fading, or if already showing a callout
            if (isZoomedIn || hoveredNode || isCalloutFading || currentCalloutNode) return;
            
            // Don't show during resume transformation
            if (isTransformingToResume || isResumeMode) return;
            
            const allNodes = skillTree.getSkillNodes();
            if (allNodes.length === 0) return;
            
            // Try up to 10 times to find a visible node
            let attempts = 0;
            let randomNode = null;
            let worldPos = new THREE.Vector3();
            let screenPos = null;
            let x, y;
            
            while (attempts < 10) {
                randomNode = allNodes[Math.floor(Math.random() * allNodes.length)];
                randomNode.getWorldPosition(worldPos);
                
                // Project to screen space
                screenPos = worldPos.clone().project(camera);
                x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                y = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
                
                // Check if node is visible and in front of camera
                if (screenPos.z <= 1 && x >= 0 && x <= window.innerWidth && y >= 0 && y <= window.innerHeight) {
                    break; // Found a good node
                }
                
                attempts++;
                randomNode = null;
            }
            
            if (!randomNode) return; // Couldn't find a visible node
            
            showCalloutForNode(randomNode, false);
        }
        
        function drawSegmentedLine(startX, startY, endX, endY, isLeft, progress, fadeOpacity = 1) {
            calloutCtx.clearRect(0, 0, calloutLine.width, calloutLine.height);
            
            // Apply fade opacity to stroke color - green for nature theme, cyan for tech
            const opacity = (isMobile ? 0.4 : 0.6) * fadeOpacity;
            const lineColor = currentTheme === 'nature' ? `rgba(102, 187, 106, ${opacity})` : `rgba(0, 255, 255, ${opacity})`;
            calloutCtx.strokeStyle = lineColor;
            calloutCtx.lineWidth = isMobile ? 1 : 2;
            calloutCtx.setLineDash(isMobile ? [3, 3] : [5, 5]);
            calloutCtx.lineCap = 'round';
            calloutCtx.lineJoin = 'round';
            
            calloutCtx.beginPath();
            calloutCtx.moveTo(startX, startY);
            
            if (isMobile) {
                // Simple straight line from top center down to node
                const totalLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const currentLength = totalLength * progress;
                
                if (currentLength > 0) {
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY + (endY - startY) * progress;
                    calloutCtx.lineTo(currentX, currentY);
                }
            } else {
                // L-shaped path for desktop: horizontal segment then to node
                const horizontalLength = 150;
                const cornerX = isLeft ? startX + horizontalLength : startX - horizontalLength;
                const cornerY = startY;
                
                // Calculate total path length
                const segment1Length = Math.abs(cornerX - startX);
                const segment2Length = Math.sqrt(Math.pow(endX - cornerX, 2) + Math.pow(endY - cornerY, 2));
                const totalLength = segment1Length + segment2Length;
                
                // Calculate current draw distance
                const currentLength = totalLength * progress;
                
                if (currentLength <= segment1Length) {
                    // Drawing horizontal segment
                    const segmentProgress = currentLength / segment1Length;
                    const currentX = startX + (cornerX - startX) * segmentProgress;
                    calloutCtx.lineTo(currentX, startY);
                } else {
                    // Horizontal segment complete, draw to corner then toward node
                    calloutCtx.lineTo(cornerX, cornerY);
                    
                    // Calculate progress on second segment
                    const segment2Progress = (currentLength - segment1Length) / segment2Length;
                    const currentX = cornerX + (endX - cornerX) * segment2Progress;
                    const currentY = cornerY + (endY - cornerY) * segment2Progress;
                    calloutCtx.lineTo(currentX, currentY);
                }
            }
            
            calloutCtx.stroke();
        }
        
        function updateCalloutLine() {
            // Don't show line during resume transformation
            if (isTransformingToResume || isResumeMode) {
                calloutCtx.clearRect(0, 0, calloutLine.width, calloutLine.height);
                lineDrawProgress = 0;
                return;
            }
            
            if (!currentCalloutNode || isZoomedIn) {
                calloutCtx.clearRect(0, 0, calloutLine.width, calloutLine.height);
                lineDrawProgress = 0;
                return;
            }
            
            // Don't show line if hovering a different node
            if (hoveredNode && hoveredNode !== currentCalloutNode) {
                calloutCtx.clearRect(0, 0, calloutLine.width, calloutLine.height);
                return;
            }
            
            // Get current world position (accounts for rotation)
            const worldPos = new THREE.Vector3();
            currentCalloutNode.getWorldPosition(worldPos);
            
            // Project to screen space
            const screenPos = worldPos.clone().project(camera);
            const nodeX = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const nodeY = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
            
            // Check if still visible
            if (screenPos.z > 1 || nodeX < 0 || nodeX > window.innerWidth || nodeY < 0 || nodeY > window.innerHeight) {
                // Node rotated out of view, hide callout
                hideCallout(!isHoverCallout);
                return;
            }
            
            // Determine which side the balloon is on
            const isLeft = calloutBalloon.classList.contains('left');
            const isCenter = calloutBalloon.classList.contains('center');
            
            // Adjust balloon position for mobile
            let balloonX, balloonY;
            if (isMobile && isCenter) {
                balloonX = window.innerWidth / 2; // Center horizontally
                balloonY = 100; // Match CSS top position (where skill tree header appears)
            } else if (isMobile) {
                balloonX = window.innerWidth / 2; // Center horizontally even if left/right class
                balloonY = 100; // Match CSS top position
            } else {
                balloonX = isLeft ? 340 : window.innerWidth - 340;
                balloonY = window.innerHeight / 2;
            }
            
            // Animate line drawing (complete in 0.5 seconds)
            const elapsed = Date.now() - calloutShowTime;
            const drawDuration = 500; // 0.5 seconds to draw line
            lineDrawProgress = Math.min(1, elapsed / drawDuration);
            
            // Handle line fade out
            if (isLineFading) {
                const fadeDuration = LINE_FADE_DURATION;
                lineFadeProgress = Math.max(0, 1 - (elapsed - (CALLOUT_DISPLAY_DURATION - LINE_FADE_DURATION - 500)) / fadeDuration);
            }
            
            // Draw the segmented line with animation and fade
            drawSegmentedLine(balloonX, balloonY, nodeX, nodeY, isLeft, lineDrawProgress, lineFadeProgress);
        }
        
        function hideCallout(showNext = false) {
            if (!currentCalloutNode) return; // Already hidden
            
            // Clear all pending timeouts to prevent race conditions
            calloutTimeouts.forEach(timeout => clearTimeout(timeout));
            calloutTimeouts = [];
            
            isCalloutFading = true;
            isLineFading = false;
            calloutBalloon.classList.remove('visible');
            
            setTimeout(() => {
                calloutCtx.clearRect(0, 0, calloutLine.width, calloutLine.height);
                currentCalloutNode = null;
                lineDrawProgress = 0;
                lineFadeProgress = 1;
                isCalloutFading = false;
                isHoverCallout = false;
                
                // Immediately show next callout if requested (maintain continuous display)
                if (showNext && !isZoomedIn && !hoveredNode) {
                    setTimeout(() => showRandomCallout(), 100);
                }
            }, 800); // Match CSS transition time
        }
        
        // Schedule auto-resume of callouts after idle period
        function scheduleAutoResume() {
            // Clear any existing timeout
            if (autoResumeTimeout) {
                clearTimeout(autoResumeTimeout);
            }
            
            // Set new timeout to resume after 3 seconds of no interaction
            autoResumeTimeout = setTimeout(() => {
                if (!hoveredNode && !isZoomedIn && !currentCalloutNode && !isCalloutFading) {
                    showRandomCallout();
                }
            }, 3000);
        }
        
        // Start random callouts after animation completes (only if not mobile)
        if (enableAutoCallouts) {
            setTimeout(() => {
                // Show first callout immediately
                if (!skillTree.isAnimating) {
                    showRandomCallout();
                }
                // Callouts will continue automatically via hideCallout(true) callback
                // No interval needed - prevents rapid cycling bug
            }, 7000); // Start after 7 seconds (seed animation + tree growth)
        }
        
        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNode = null;
        let isZoomedIn = false;
        
        // Camera animation state
        let cameraAnimation = null;
        const savedCameraPosition = new THREE.Vector3();
        const savedCameraTarget = new THREE.Vector3();
        
        // Animate camera smoothly
        function animateCamera(fromPos, toPos, fromTarget, toTarget, duration, onComplete) {
            const startTime = Date.now();
            
            cameraAnimation = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : -1 + (4 - 2 * progress) * progress;
                
                // Interpolate position
                camera.position.lerpVectors(fromPos, toPos, eased);
                controls.target.lerpVectors(fromTarget, toTarget, eased);
                controls.update();
                
                if (progress >= 1) {
                    clearInterval(cameraAnimation);
                    cameraAnimation = null;
                    if (onComplete) onComplete();
                }
            }, 16); // ~60fps
        }
        
        // Show skill details
        function showSkillDetail(node) {
            const data = node.userData.skillData;
            const parentChain = node.userData.parentChain || [];
            
            // Set skill name
            document.getElementById('detail-name').textContent = data.name;
            
            // Build breadcrumb navigation
            const breadcrumb = parentChain.slice(0, -1).join('  ');
            document.getElementById('detail-breadcrumb').innerHTML = breadcrumb ? 
                `<span style="opacity: 0.7;">Path:</span> ${breadcrumb}` : '';
            
            // Set category
            document.getElementById('detail-category').innerHTML = 
                `<strong>Category:</strong> ${node.userData.category || 'N/A'}`;
            
            // Set level and experience
            document.getElementById('detail-level').innerHTML = 
                `<strong>Level:</strong> ${data.level || 'N/A'}`;
            document.getElementById('detail-experience').innerHTML = 
                `<strong>Experience:</strong> ${data.yearsExp || 0} years`;
            
            // Set description
            document.getElementById('detail-description').textContent = 
                data.description || 'No description available.';
            
            // Build additional information section
            const additionalDiv = document.getElementById('detail-additional');
            additionalDiv.innerHTML = '';
            
            // Show any additional properties
            const additionalProps = [];
            if (data.projects) additionalProps.push(`<strong>Projects:</strong> ${data.projects}`);
            if (data.tools) additionalProps.push(`<strong>Tools:</strong> ${Array.isArray(data.tools) ? data.tools.join(', ') : data.tools}`);
            if (data.certifications) additionalProps.push(`<strong>Certifications:</strong> ${data.certifications}`);
            if (data.lastUsed) additionalProps.push(`<strong>Last Used:</strong> ${data.lastUsed}`);
            
            if (additionalProps.length > 0) {
                additionalDiv.innerHTML = additionalProps.map(prop => 
                    `<p style="margin: 8px 0; color: #ccc; font-size: 14px;">${prop}</p>`
                ).join('');
            }
            
            document.getElementById('skill-detail').style.display = 'block';
        }
        
        // Hide skill details
        function hideSkillDetail() {
            document.getElementById('skill-detail').style.display = 'none';
        }
        
        // Zoom in to node
        function zoomToNode(node) {
            if (isZoomedIn || cameraAnimation) return;
            
            isZoomedIn = true;
            
            // Hide any active callout when selecting a node
            if (currentCalloutNode) {
                hideCallout(false); // Don't show next callout
            }
            
            // Save current camera state
            savedCameraPosition.copy(camera.position);
            savedCameraTarget.copy(controls.target);
            
            // Get node's world position (accounts for tree rotation)
            const worldPos = new THREE.Vector3();
            node.getWorldPosition(worldPos);
            
            // Calculate zoom position
            const offset = new THREE.Vector3(1, 0.5, 2); // Close-up offset
            const targetCameraPos = worldPos.clone().add(offset);
            
            // Animate camera
            animateCamera(
                savedCameraPosition,
                targetCameraPos,
                savedCameraTarget,
                worldPos,
                1000, // 1 second
                () => {
                    showSkillDetail(node);
                    updateNavigationUI(node); // Show navigation controls
                    controls.enabled = false; // Disable controls while zoomed
                }
            );
            
            skillTree.selectSkill(node);
        }
        
        // Zoom out to orbit view
        function zoomOut() {
            if (!isZoomedIn || cameraAnimation) return;
            
            isZoomedIn = false;
            hideSkillDetail();
            hideNavigationUI(); // Hide navigation controls
            
            // Expand the experience panel and trunk when zooming out
            document.getElementById('roots-panel').classList.remove('collapsed');
            document.getElementById('trunk-ui').classList.remove('collapsed');
            
            // Animate back to saved position
            animateCamera(
                camera.position.clone(),
                savedCameraPosition,
                controls.target.clone(),
                savedCameraTarget,
                1000, // 1 second
                () => {
                    controls.enabled = true; // Re-enable controls
                    skillTree.selectSkill(null); // Deselect
                    
                    // Resume callouts after zoom out
                    scheduleAutoResume();
                }
            );
        }
        
        // ===== TREE NAVIGATION SYSTEM =====
        let currentNavigationNode = null;
        let currentChildIndex = 0;
        let currentSiblingIndex = 0;
        
        const treeNavigation = document.getElementById('tree-navigation');
        const navUp = document.getElementById('nav-up');
        const navDown = document.getElementById('nav-down');
        const navLeft = document.getElementById('nav-left');
        const navRight = document.getElementById('nav-right');
        
        // Get parent node from the tree structure
        function getParentNode(node) {
            if (!node || !node.userData || !node.userData.parentChain) return null;
            
            const parentChain = node.userData.parentChain;
            if (parentChain.length < 2) return null; // No parent (root level)
            
            const parentName = parentChain[parentChain.length - 2]; // Second-to-last is parent
            
            // Find the parent node by name
            const allNodes = skillTree.getSkillNodes();
            for (let potentialParent of allNodes) {
                if (potentialParent.userData.skillData.name === parentName) {
                    return potentialParent;
                }
            }
            return null;
        }
        
        // Get children nodes
        function getChildrenNodes(node) {
            if (!node || !node.userData || !node.userData.skillData) return [];
            
            const skillData = node.userData.skillData;
            if (!skillData.children || skillData.children.length === 0) return [];
            
            // Find all nodes that have this node in their parent chain
            const allNodes = skillTree.getSkillNodes();
            const children = [];
            
            for (let potentialChild of allNodes) {
                const childChain = potentialChild.userData.parentChain;
                if (childChain && childChain.length > 0) {
                    // Check if this node is the immediate parent
                    const childParentName = childChain[childChain.length - 2];
                    if (childParentName === node.userData.skillData.name) {
                        children.push(potentialChild);
                    }
                }
            }
            
            return children;
        }
        
        // Get sibling nodes
        function getSiblingNodes(node) {
            const parent = getParentNode(node);
            if (!parent) return [];
            
            const siblings = getChildrenNodes(parent);
            return siblings.filter(sibling => sibling !== node);
        }
        
        // Update navigation UI based on current node
        function updateNavigationUI(node) {
            currentNavigationNode = node;
            
            const parent = getParentNode(node);
            const children = getChildrenNodes(node);
            const siblings = getSiblingNodes(node);
            
            // Reset indices
            currentChildIndex = 0;
            currentSiblingIndex = 0;
            
            // UP arrow = First child (going UP the tree visually)
            navUp.disabled = children.length === 0;
            if (children.length > 0) {
                navUp.setAttribute('data-target', children[0].userData.skillData.name);
            } else {
                navUp.setAttribute('data-target', '');
            }
            
            // DOWN arrow = Parent (going DOWN toward roots)
            navDown.disabled = !parent || !parent.userData || !parent.userData.isSkillNode;
            if (parent && parent.userData && parent.userData.isSkillNode) {
                navDown.setAttribute('data-target', parent.userData.skillData.name);
            } else {
                navDown.setAttribute('data-target', '');
            }
            
            // LEFT/RIGHT arrows = Siblings OR cycle through children
            if (siblings.length > 0) {
                // Find current position among siblings
                const allSiblings = [...siblings, node].sort((a, b) => {
                    const parent = getParentNode(node);
                    if (!parent) return 0;
                    const parentChildren = getChildrenNodes(parent);
                    return parentChildren.indexOf(a) - parentChildren.indexOf(b);
                });
                currentSiblingIndex = allSiblings.indexOf(node);
                
                // Enable/disable based on position (swapped for left/right)
                navLeft.disabled = currentSiblingIndex === allSiblings.length - 1; // Left goes to next, so disable at end
                navRight.disabled = currentSiblingIndex === 0; // Right goes to previous, so disable at start
                navLeft.setAttribute('data-mode', 'sibling');
                navRight.setAttribute('data-mode', 'sibling');
                
                // Set target names (swapped)
                if (currentSiblingIndex < allSiblings.length - 1) {
                    navLeft.setAttribute('data-target', allSiblings[currentSiblingIndex + 1].userData.skillData.name);
                } else {
                    navLeft.setAttribute('data-target', '');
                }
                if (currentSiblingIndex > 0) {
                    navRight.setAttribute('data-target', allSiblings[currentSiblingIndex - 1].userData.skillData.name);
                } else {
                    navRight.setAttribute('data-target', '');
                }
            } else if (children.length > 1) {
                // No siblings but multiple children - use left/right to cycle children
                navLeft.disabled = false;
                navRight.disabled = false;
                navLeft.setAttribute('data-mode', 'child');
                navRight.setAttribute('data-mode', 'child');
                
                // Set target names (swapped - left goes next, right goes previous)
                const nextChildIndex = (currentChildIndex + 1) % children.length;
                const prevChildIndex = (currentChildIndex - 1 + children.length) % children.length;
                navLeft.setAttribute('data-target', children[nextChildIndex].userData.skillData.name);
                navRight.setAttribute('data-target', children[prevChildIndex].userData.skillData.name);
            } else {
                // No siblings and 0-1 children - disable left/right
                navLeft.disabled = true;
                navRight.disabled = true;
                navLeft.setAttribute('data-target', '');
                navRight.setAttribute('data-target', '');
            }
            
            // Show navigation
            treeNavigation.style.display = 'block';
            setTimeout(() => treeNavigation.classList.add('visible'), 10);
        }
        
        // Hide navigation UI
        function hideNavigationUI() {
            treeNavigation.classList.remove('visible');
            setTimeout(() => {
                treeNavigation.style.display = 'none';
                currentNavigationNode = null;
            }, 300);
        }
        
        // Navigate to a different node
        function navigateToNode(targetNode) {
            if (!targetNode || !targetNode.userData || !targetNode.userData.isSkillNode) {
                console.log('Invalid target node:', targetNode);
                return;
            }
            
            // Clear any existing camera animation
            if (cameraAnimation) {
                clearInterval(cameraAnimation);
                cameraAnimation = null;
            }
            
            // Get target world position
            const worldPos = new THREE.Vector3();
            targetNode.getWorldPosition(worldPos);
            
            // Calculate new camera position
            const offset = new THREE.Vector3(1, 0.5, 2);
            const targetCameraPos = worldPos.clone().add(offset);
            
            // Animate to new node
            animateCamera(
                camera.position.clone(),
                targetCameraPos,
                controls.target.clone(),
                worldPos,
                600, // Faster transition between nodes
                () => {
                    // Update UI after animation completes
                    showSkillDetail(targetNode);
                    updateNavigationUI(targetNode);
                    skillTree.selectSkill(targetNode);
                }
            );
        }
        
        // Navigation button handlers
        navUp.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (navUp.disabled || !currentNavigationNode) {
                console.log('Nav Up disabled or no current node');
                return;
            }
            // UP goes to first child (up the tree visually)
            const children = getChildrenNodes(currentNavigationNode);
            console.log('Nav Up - Children:', children);
            if (children.length > 0) {
                navigateToNode(children[0]);
            }
        });
        
        navDown.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (navDown.disabled || !currentNavigationNode) {
                console.log('Nav Down disabled or no current node');
                return;
            }
            // DOWN goes to parent (down toward roots)
            const parent = getParentNode(currentNavigationNode);
            console.log('Nav Down - Parent:', parent);
            if (parent) navigateToNode(parent);
        });
        
        navLeft.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (navLeft.disabled || !currentNavigationNode) {
                console.log('Nav Left disabled or no current node');
                return;
            }
            
            const mode = navLeft.getAttribute('data-mode');
            console.log('Nav Left - Mode:', mode);
            
            if (mode === 'sibling') {
                // Navigate to NEXT sibling (swapped)
                const siblings = getSiblingNodes(currentNavigationNode);
                const allSiblings = [...siblings, currentNavigationNode].sort((a, b) => {
                    const parent = getParentNode(currentNavigationNode);
                    if (!parent) return 0;
                    const parentChildren = getChildrenNodes(parent);
                    return parentChildren.indexOf(a) - parentChildren.indexOf(b);
                });
                
                if (currentSiblingIndex < allSiblings.length - 1) {
                    console.log('Navigating to next sibling:', allSiblings[currentSiblingIndex + 1]);
                    navigateToNode(allSiblings[currentSiblingIndex + 1]);
                }
            } else if (mode === 'child') {
                // Cycle to NEXT child (swapped)
                const children = getChildrenNodes(currentNavigationNode);
                if (children.length > 0) {
                    currentChildIndex = (currentChildIndex + 1) % children.length;
                    console.log('Navigating to next child:', children[currentChildIndex]);
                    navigateToNode(children[currentChildIndex]);
                }
            }
        });
        
        navRight.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (navRight.disabled || !currentNavigationNode) {
                console.log('Nav Right disabled or no current node');
                return;
            }
            
            const mode = navRight.getAttribute('data-mode');
            console.log('Nav Right - Mode:', mode);
            
            if (mode === 'sibling') {
                // Navigate to PREVIOUS sibling (swapped)
                const siblings = getSiblingNodes(currentNavigationNode);
                const allSiblings = [...siblings, currentNavigationNode].sort((a, b) => {
                    const parent = getParentNode(currentNavigationNode);
                    if (!parent) return 0;
                    const parentChildren = getChildrenNodes(parent);
                    return parentChildren.indexOf(a) - parentChildren.indexOf(b);
                });
                
                if (currentSiblingIndex > 0) {
                    console.log('Navigating to previous sibling:', allSiblings[currentSiblingIndex - 1]);
                    navigateToNode(allSiblings[currentSiblingIndex - 1]);
                }
            } else if (mode === 'child') {
                // Cycle to PREVIOUS child (swapped)
                const children = getChildrenNodes(currentNavigationNode);
                if (children.length > 0) {
                    currentChildIndex = (currentChildIndex - 1 + children.length) % children.length;
                    console.log('Navigating to previous child:', children[currentChildIndex]);
                    navigateToNode(children[currentChildIndex]);
                }
            }
        });
        
        // Close button handler
        document.getElementById('close-detail').addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            hideNavigationUI();
            zoomOut();
        });
        
        // Only close on ESC key or close button
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isZoomedIn) {
                hideNavigationUI();
                zoomOut();
            }
        });
        
        // Shared function to update hover state
        function updateHoverState(clientX, clientY) {
            if (isZoomedIn) return; // Disable hover when zoomed in
            
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Update tree world matrix to account for rotation
            if (skillTree.tree) {
                skillTree.tree.updateMatrixWorld(true);
            }
            
            const nodes = skillTree.getSkillNodes();
            const intersects = raycaster.intersectObjects(nodes);
            
            // Reset previous hover
            if (hoveredNode) {
                hoveredNode.userData.isHovered = false;
                hoveredNode.material.emissiveIntensity = hoveredNode.userData.baseEmissive;
                document.body.style.cursor = 'default';
            }
            
            if (intersects.length > 0) {
                hoveredNode = intersects[0].object;
                hoveredNode.userData.isHovered = true;
                hoveredNode.material.emissiveIntensity = 1.0;
                document.body.style.cursor = 'pointer';
                
                // Show callout for hovered node
                if (currentCalloutNode !== hoveredNode) {
                    // Hide previous callout without showing next random one
                    if (currentCalloutNode) {
                        hideCallout(false);
                    }
                    // Show callout for this node after brief delay to prevent flicker
                    const showDelay = currentCalloutNode ? 100 : 0;
                    const hoverTimeout = setTimeout(() => {
                        if (hoveredNode) { // Check if still hovering
                            showCalloutForNode(hoveredNode, true);
                        }
                    }, showDelay);
                    // Don't add to calloutTimeouts since this is hover-triggered
                }
                
                // Update info display
                const data = hoveredNode.userData.skillData;
                document.getElementById('skill-count').innerHTML = 
                    `<strong>${data.name}</strong><br>` +
                    `${data.level || 'N/A'} | ${data.yearsExp || 0} years`;
            } else {
                const wasHovering = hoveredNode !== null;
                hoveredNode = null;
                const root = skillTree.tree.userData.root || {};
                document.getElementById('skill-count').textContent = isMobile ? 'Tap skills to explore' : 'Hover over skills to learn more';
                
                // Resume callouts after user stops hovering
                if (wasHovering) {
                    lastInteractionTime = Date.now();
                    scheduleAutoResume();
                }
            }
        }
        
        // Mouse move for hover (desktop)
        window.addEventListener('mousemove', (event) => {
            if (!isZoomedIn && !isTransformingToResume && !isResumeMode) {
                updateHoverState(event.clientX, event.clientY);
                lastInteractionTime = Date.now();
            }
        });
        
        // Touch move for hover simulation (works on mobile and desktop touch screens)
        if (hasTouch) {
            window.addEventListener('touchmove', (event) => {
                if (!isZoomedIn && !isTransformingToResume && !isResumeMode && event.touches[0] && !touchMoved) {
                    // Only simulate hover if we haven't moved much (not dragging)
                    updateHoverState(event.touches[0].clientX, event.touches[0].clientY);
                    lastInteractionTime = Date.now();
                }
            });
        }
        
        // Touch/Click handling for node selection
        let touchStartTime = 0;
        let touchMoved = false;
        let touchStartPos = { x: 0, y: 0 };
        
        // Touch start - combined handler for both hover and click detection (mobile and desktop touch)
        if (hasTouch) {
            window.addEventListener('touchstart', (event) => {
                if (isZoomedIn || isTransformingToResume || isResumeMode) return;
                
                // Handle hover simulation first
                if (event.touches[0]) {
                    updateHoverState(event.touches[0].clientX, event.touches[0].clientY);
                }
                
                // Setup for click detection
                touchStartTime = Date.now();
                touchMoved = false;
                
                if (event.touches[0]) {
                    touchStartPos.x = event.touches[0].clientX;
                    touchStartPos.y = event.touches[0].clientY;
                }
            });
            
            // Touch move - track if user is dragging
            window.addEventListener('touchmove', (event) => {
                if (event.touches[0]) {
                    const moveDistance = Math.sqrt(
                        Math.pow(event.touches[0].clientX - touchStartPos.x, 2) + 
                        Math.pow(event.touches[0].clientY - touchStartPos.y, 2)
                    );
                    
                    // Consider it a move if moved more than 10 pixels
                    if (moveDistance > 10) {
                        touchMoved = true;
                    }
                }
            });
            
            // Touch end - handle tap vs drag
            window.addEventListener('touchend', (event) => {
                if (isZoomedIn || isTransformingToResume || isResumeMode) return;
                
                const touchDuration = Date.now() - touchStartTime;
                
                // Only consider it a tap if:
                // 1. Duration is less than 500ms (not a long press)
                // 2. User didn't move much (not a drag)
                if (touchDuration < 500 && !touchMoved && hoveredNode) {
                    event.preventDefault(); // Prevent double-tap zoom
                    lastInteractionTime = Date.now();
                    scheduleAutoResume();
                    zoomToNode(hoveredNode);
                }
            });
        }
        
        // Click to select and focus camera (desktop and desktop touch screens)
        window.addEventListener('click', (event) => {
            if (isZoomedIn || isTransformingToResume || isResumeMode) return; // Prevent clicks when already zoomed
            
            // Skip if this is a mobile device to avoid duplicate events with touch
            if (isMobile) return;
            
            if (hoveredNode) {
                lastInteractionTime = Date.now(); // Update interaction time
                scheduleAutoResume();
                zoomToNode(hoveredNode);
            }
        });
        
        // ===== RESUME TRANSFORMATION ANIMATION =====
        let isTransformingToResume = false;
        let isResumeMode = false;
        let axe = null;
        let axeHandle = null;
        let axeBlade = null;
        
        // Create axe geometry
        function createAxe() {
            const axeGroup = new THREE.Group();
            
            // Wooden handle
            const handleGeometry = new THREE.CylinderGeometry(0.12, 0.18, 3.5, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x654321,
                flatShading: true
            });
            axeHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            axeHandle.position.y = -0.5;
            axeGroup.add(axeHandle);
            
            // Metal blade - wedge shape
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(2, 1);
            bladeShape.lineTo(2, -1);
            bladeShape.lineTo(0, 0);
            
            const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 };
            const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, extrudeSettings);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xB0B0B0,
                shininess: 100,
                flatShading: false
            });
            axeBlade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            axeBlade.position.set(0.2, 1.5, -0.075);
            axeGroup.add(axeBlade);
            
            // Position axe off-screen initially
            axeGroup.position.set(-15, 5, 0);
            axeGroup.rotation.z = Math.PI / 4;
            axeGroup.visible = false;
            
            return axeGroup;
        }
        
        // Animate camera zooming to trunk
        function animateCameraToTrunk() {
            return new Promise((resolve) => {
                const zoomDuration = 1500;
                const startTime = Date.now();
                const startPos = camera.position.clone();
                const targetPos = new THREE.Vector3(0, -2, 15);
                const startTarget = controls.target.clone();
                const targetTarget = new THREE.Vector3(0, -2, 0);
                
                const animateZoom = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / zoomDuration, 1);
                    
                    // Smooth ease in-out
                    const eased = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    // Move camera toward trunk
                    camera.position.lerpVectors(startPos, targetPos, eased);
                    controls.target.lerpVectors(startTarget, targetTarget, eased);
                    controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateZoom);
                    } else {
                        resolve();
                    }
                };
                
                animateZoom();
            });
        }
        
        // Create wood chip particles
        function createWoodChips() {
            const chips = [];
            const chipGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.05);
            const chipMaterial = new THREE.MeshPhongMaterial({ color: 0x8B5A2B });
            
            for (let i = 0; i < 20; i++) {
                const chip = new THREE.Mesh(chipGeometry, chipMaterial);
                chip.position.set(0, -2, 0);
                chip.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.2 + 0.1,
                    (Math.random() - 0.5) * 0.3
                );
                chip.rotationVel = new THREE.Vector3(
                    Math.random() * 0.2,
                    Math.random() * 0.2,
                    Math.random() * 0.2
                );
                scene.add(chip);
                chips.push(chip);
            }
            return chips;
        }
        
        // Animate axe chopping
        function animateAxeChop() {
            return new Promise((resolve) => {
                if (!axe) {
                    axe = createAxe();
                    scene.add(axe);
                }
                
                axe.visible = true;
                const trunkY = -2; // Height of trunk cut
                
                // Starting position: right side, ready for horizontal chop
                axe.position.set(12, trunkY, 0);
                axe.rotation.z = 0; // Horizontal orientation
                
                // Wind-up + swing
                const swingInDuration = 400;    // Pendulum swing in
                const windUpDuration = 600;     // Wind-up before chop
                const swingDuration = 400;      // Fast chop
                const totalDuration = swingInDuration + windUpDuration + swingDuration;
                const startTime = Date.now();
                let woodChips = null;
                
                const animateChop = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    if (elapsed < swingInDuration) {
                        // Phase 1: Pendulum swing in from off-screen
                        const swingProgress = elapsed / swingInDuration;
                        const swingEased = 1 - Math.pow(1 - swingProgress, 3); // Ease out
                        
                        // Swing from far right (off-screen) to ready position
                        axe.position.x = 20 - (8 * swingEased); // 20 -> 12
                        
                        // Pendulum rotation as it swings in
                        axe.rotation.z = Math.sin(swingProgress * Math.PI) * Math.PI / 8; // Swing motion
                        
                    } else if (elapsed < swingInDuration + windUpDuration) {
                        // Phase 2: Wind-up (pull back and rotate)
                        const windProgress = (elapsed - swingInDuration) / windUpDuration;
                        const windEased = Math.sin(windProgress * Math.PI / 2); // Ease out
                        
                        axe.position.x = 12 + (3 * windEased); // Pull further right
                        axe.rotation.z = -Math.PI / 6 * windEased; // Rotate back
                        
                    } else {
                        // Phase 3: Fast horizontal chop
                        const swingProgress = (elapsed - swingInDuration - windUpDuration) / swingDuration;
                        const swingEased = 1 - Math.pow(1 - swingProgress, 4); // Fast acceleration
                        
                        // Horizontal swing from right to center trunk
                        axe.position.x = 15 - (15 * swingEased);
                        axe.rotation.z = -Math.PI / 6 + (Math.PI / 6 * swingEased);
                        
                        // Add spinning rotation after impact
                        if (swingProgress > 0.7) {
                            const spinProgress = (swingProgress - 0.7) / 0.3; // Last 30% of swing
                            axe.rotation.y = spinProgress * Math.PI * 4; // Multiple rotations
                        }
                        
                        // Create wood chips at impact
                        if (swingProgress > 0.7 && !woodChips) {
                            woodChips = createWoodChips();
                        }
                    }
                    
                    // Animate wood chips
                    if (woodChips) {
                        woodChips.forEach(chip => {
                            chip.position.add(chip.velocity);
                            chip.velocity.y -= 0.01; // Gravity
                            chip.rotation.x += chip.rotationVel.x;
                            chip.rotation.y += chip.rotationVel.y;
                            chip.rotation.z += chip.rotationVel.z;
                        });
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateChop);
                    } else {
                        // Hold for a moment, then clean up
                        setTimeout(() => {
                            axe.visible = false;
                            if (woodChips) {
                                woodChips.forEach(chip => scene.remove(chip));
                            }
                            resolve();
                        }, 400);
                    }
                };
                
                animateChop();
            });
        }
        
        // Animate tree falling
        function animateTreeFalling() {
            return new Promise((resolve) => {
                // Disable controls
                controls.enabled = false;
                
                // Stop all interactions
                isTransformingToResume = true;
                
                const fallDuration = 2500;
                const startTime = Date.now();
                const startRotation = skillTree.tree.rotation.clone();
                
                // Track individual node physics
                const nodePhysics = [];
                skillTree.tree.traverse((obj) => {
                    if (obj.isMesh && obj.userData.skill) {
                        nodePhysics.push({
                            mesh: obj,
                            velocity: new THREE.Vector3(0, 0, 0),
                            startY: obj.position.y,
                            hasHitGround: false,
                            bounceVelocity: 0
                        });
                    }
                });
                
                const animateFall = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / fallDuration, 1);
                    
                    // Gravity-like easing (accelerate then decelerate on impact)
                    const eased = progress < 0.7
                        ? Math.pow(progress / 0.7, 2)
                        : 1 - Math.pow((progress - 0.7) / 0.3, 2) * 0.3;
                    
                    // Rotate tree 90 degrees around X axis (falling over)
                    skillTree.tree.rotation.x = startRotation.x - (Math.PI / 2 * eased);
                    
                    // Movement down as it falls with bounce
                    if (progress < 0.7) {
                        skillTree.tree.position.y = -8 * eased;
                    } else {
                        // Bounce effect
                        const bounceProgress = (progress - 0.7) / 0.3;
                        const bounce = Math.sin(bounceProgress * Math.PI) * 0.5;
                        skillTree.tree.position.y = -8 + bounce;
                    }
                    
                    // Individual node physics for scattered effect
                    if (progress > 0.6) {
                        nodePhysics.forEach(np => {
                            if (!np.hasHitGround) {
                                np.velocity.y -= 0.02; // Gravity
                                np.mesh.position.y += np.velocity.y;
                                
                                // Check if hit ground (relative to fallen tree)
                                if (np.mesh.position.y < np.startY - 3) {
                                    np.hasHitGround = true;
                                    np.bounceVelocity = Math.abs(np.velocity.y) * 0.4;
                                }
                            } else if (np.bounceVelocity > 0.01) {
                                // Bounce back up
                                np.mesh.position.y += np.bounceVelocity;
                                np.bounceVelocity *= 0.85; // Damping
                            }
                        });
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateFall);
                    } else {
                        resolve();
                    }
                };
                
                animateFall();
            });
        }
        
        // Animate paper machine transformation
        function animatePaperMachine() {
            return new Promise((resolve) => {
                const transformDuration = 2000;
                const startTime = Date.now();
                
                // Collect all nodes and branches
                const allObjects = [];
                skillTree.tree.traverse((obj) => {
                    if (obj.isMesh) {
                        allObjects.push({
                            mesh: obj,
                            startPos: obj.position.clone(),
                            startScale: obj.scale.clone()
                        });
                    }
                });
                
                const machineCenter = new THREE.Vector3(0, 0, 5);
                
                const animateTransform = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / transformDuration, 1);
                    
                    // Ease in
                    const eased = progress * progress;
                    
                    // Shrink and move all objects to center
                    allObjects.forEach(({mesh, startPos, startScale}) => {
                        // Move toward machine center
                        mesh.position.lerpVectors(startPos, machineCenter, eased);
                        
                        // Shrink to nothing
                        const scale = 1 - eased;
                        mesh.scale.set(
                            startScale.x * scale,
                            startScale.y * scale,
                            startScale.z * scale
                        );
                        
                        // Fade out
                        if (mesh.material) {
                            mesh.material.opacity = 1 - eased;
                            mesh.material.transparent = true;
                        }
                    });
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateTransform);
                    } else {
                        // Hide tree completely
                        skillTree.tree.visible = false;
                        resolve();
                    }
                };
                
                animateTransform();
            });
        }
        
        // Create white paper plane
        function createPaperPlane() {
            const planeGeometry = new THREE.PlaneGeometry(16, 20);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                side: THREE.FrontSide
            });
            const paper = new THREE.Mesh(planeGeometry, planeMaterial);
            paper.position.set(0, 0, 0);
            
            // Orient plane to face camera
            paper.lookAt(camera.position);
            paper.userData.isPaper = true;
            
            // Start small
            paper.scale.set(0.01, 0.01, 0.01);
            scene.add(paper);
            
            return paper;
        }
        
        // Animate paper appearing and zooming to fill screen
        function animatePaperAppear(paper) {
            return new Promise((resolve) => {
                const growDuration = 1000; // Grow to normal size
                const zoomDuration = 800;  // Zoom to fill screen
                const totalDuration = growDuration + zoomDuration;
                const startTime = Date.now();
                
                const animateGrow = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    if (elapsed < growDuration) {
                        // Phase 1: Grow to normal size
                        const growProgress = elapsed / growDuration;
                        const growEased = 1 - Math.pow(1 - growProgress, 3);
                        paper.scale.set(growEased, growEased, growEased);
                    } else {
                        // Phase 2: Zoom to fill entire screen
                        const zoomProgress = (elapsed - growDuration) / zoomDuration;
                        const zoomEased = zoomProgress < 0.5
                            ? 2 * zoomProgress * zoomProgress
                            : 1 - Math.pow(-2 * zoomProgress + 2, 2) / 2;
                        
                        // Scale from 1 to 4 (fills screen)
                        const scale = 1 + (zoomEased * 3);
                        paper.scale.set(scale, scale, scale);
                        
                        // Move towards camera slightly for full coverage
                        paper.position.z = zoomEased * 2;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateGrow);
                    } else {
                        // Keep paper visible briefly before showing resume
                        setTimeout(() => resolve(), 300);
                    }
                };
                
                animateGrow();
            });
        }
        
        // Load resume content from JSON or PDF
        async function loadResumeContent() {
            try {
                // Check if PDF exists, otherwise generate from data
                const resumePdfPath = 'resume.pdf';
                
                // Try to load PDF first
                const response = await fetch(resumePdfPath, { method: 'HEAD' });
                
                if (response.ok) {
                    // PDF exists, display it in iframe
                    const resumeHTML = `
                        <iframe 
                            src="${resumePdfPath}" 
                            style="width: 100%; height: 100%; border: none; min-height: 800px;"
                            title="Resume PDF">
                        </iframe>
                    `;
                    document.getElementById('resume-content').innerHTML = resumeHTML;
                } else {
                    throw new Error('PDF not found');
                }
            } catch (error) {
                console.log('PDF not found, generating content from data files...');
                
                // Fallback: Generate resume from JSON data files
                try {
                    // Load all data files in parallel
                    let experienceData = [];
                    let skillsData = {};
                    let projectsData = [];
                    
                    // Load experience data
                    try {
                        const expResponse = await fetch('data/experience.json');
                        if (expResponse.ok) {
                            const expJson = await expResponse.json();
                            // Extract items from all categories
                            if (expJson.categories && Array.isArray(expJson.categories)) {
                                experienceData = expJson.categories.flatMap(cat => 
                                    cat.items.map(item => ({
                                        ...item,
                                        role: item.title,
                                        category: cat.category
                                    }))
                                );
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load experience.json:', e);
                    }
                    
                    // Load skills data
                    try {
                        const skillsResponse = await fetch('data/skills.json');
                        if (skillsResponse.ok) {
                            const skillsJson = await skillsResponse.json();
                            // Flatten skills hierarchy to a simple object
                            if (skillsJson.skills && skillsJson.skills.children) {
                                const flattenSkills = (node, category = '') => {
                                    const result = {};
                                    if (node.name && node.level) {
                                        result[node.name] = {
                                            level: node.level,
                                            category: category || node.type,
                                            yearsExp: node.yearsExp || 0,
                                            color: node.color || '#8B5A2B'
                                        };
                                    }
                                    if (node.children && Array.isArray(node.children)) {
                                        node.children.forEach(child => {
                                            Object.assign(result, flattenSkills(child, node.name));
                                        });
                                    }
                                    return result;
                                };
                                
                                skillsJson.skills.children.forEach(category => {
                                    Object.assign(skillsData, flattenSkills(category));
                                });
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load skills.json:', e);
                    }
                    
                    // Load projects data
                    try {
                        const projectsResponse = await fetch('data/projects.json');
                        if (projectsResponse.ok) {
                            const projectsJson = await projectsResponse.json();
                            if (projectsJson.projects && Array.isArray(projectsJson.projects)) {
                                projectsData = projectsJson.projects;
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load projects.json:', e);
                    }
                    
                    // Generate HTML content
                    const resumeHTML = `
                        <div style="color: #333; line-height: 1.8; font-family: 'Georgia', serif; max-width: 800px; margin: 0 auto;">
                            <h1 style="color: #2c3e50; text-align: center; margin-bottom: 10px; font-size: 32px;">Professional Profile</h1>
                            <p style="text-align: center; color: #666; margin-bottom: 30px; font-size: 16px;">Full-Stack Developer | Robotics & AI Specialist</p>
                            
                            ${experienceData.length > 0 ? `
                            <h2 style="color: #2c3e50; border-bottom: 3px solid #8B5A2B; padding-bottom: 10px; margin-top: 40px; font-size: 24px;">Experience</h2>
                            ${experienceData.map(exp => `
                                <div style="margin: 25px 0; padding: 20px; background: #f8f9fa; border-left: 4px solid #8B5A2B; border-radius: 5px;">
                                    ${exp.logoUrl ? `<img src="${exp.logoUrl}" style="max-height: 40px; margin-bottom: 10px;" onerror="this.style.display='none'" alt="${exp.organization || 'Company'} logo">` : ''}
                                    <h3 style="color: #2c3e50; margin: 0 0 8px 0; font-size: 18px;">${exp.role || exp.title || 'Role'}</h3>
                                    <p style="color: #666; font-style: italic; margin: 5px 0; font-size: 14px;">
                                        <strong>${exp.organization || exp.company || 'Organization'}</strong> | ${exp.period || exp.date || 'Date'}
                                    </p>
                                    ${exp.location ? `<p style="color: #777; font-size: 13px; margin: 5px 0;"> ${exp.location}</p>` : ''}
                                    ${exp.description ? `<p style="margin: 15px 0 0 0; color: #555; line-height: 1.6;">${exp.description}</p>` : ''}
                                    ${exp.skills && exp.skills.length > 0 ? `
                                        <div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 6px;">
                                            ${exp.skills.slice(0, 8).map(skill => `
                                                <span style="background: #e3f2fd; color: #1976d2; padding: 4px 10px; border-radius: 12px; font-size: 11px;">${skill}</span>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                            ` : ''}
                            
                            ${Object.keys(skillsData).length > 0 ? `
                            <h2 style="color: #2c3e50; border-bottom: 3px solid #8B5A2B; padding-bottom: 10px; margin-top: 40px; font-size: 24px;">Technical Skills</h2>
                            <div style="margin: 20px 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                                ${Object.entries(skillsData).slice(0, 30).map(([skill, data]) => `
                                    <div style="background: #f8f9fa; padding: 12px 16px; border-radius: 5px; border-left: 3px solid ${data.color || '#8B5A2B'}; font-size: 14px;">
                                        <strong style="color: #2c3e50;">${skill}</strong>
                                        ${data.category ? `<br><span style="font-size: 11px; color: #666;">${data.category}</span>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                            ` : ''}
                            
                            ${projectsData.length > 0 ? `
                            <h2 style="color: #2c3e50; border-bottom: 3px solid #8B5A2B; padding-bottom: 10px; margin-top: 40px; font-size: 24px;">Projects</h2>
                            ${projectsData.map(project => `
                                <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                                    <h3 style="color: #2c3e50; margin: 0 0 8px 0; font-size: 16px;">
                                        ${project.url ? `<a href="${project.url}" target="_blank" style="color: #8B5A2B; text-decoration: none;">${project.name}</a>` : project.name}
                                    </h3>
                                    ${project.description ? `<p style="margin: 5px 0; color: #555; font-size: 14px;">${project.description}</p>` : ''}
                                </div>
                            `).join('')}
                            ` : ''}
                            
                            <div style="margin-top: 60px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center;">
                                <p style="color: #999; font-size: 12px; margin: 10px 0;">
                                    <em> This resume was dynamically generated from JSON data files</em>
                                </p>
                                <p style="color: #999; font-size: 12px; margin: 5px 0;">
                                    Place <strong>resume.pdf</strong> in the root directory to display your PDF resume instead
                                </p>
                            </div>
                            
                            ${experienceData.length === 0 && Object.keys(skillsData).length === 0 && projectsData.length === 0 ? `
                                <div style="text-align: center; padding: 40px 20px; color: #666;">
                                    <h3 style="color: #999; margin-bottom: 20px;">No Content Available</h3>
                                    <p style="margin: 10px 0;">Add <strong>resume.pdf</strong> to the root directory, or populate:</p>
                                    <ul style="list-style: none; padding: 0; margin: 20px 0;">
                                        <li style="margin: 8px 0;"> data/experience.json</li>
                                        <li style="margin: 8px 0;"> data/skills.json</li>
                                        <li style="margin: 8px 0;"> js/projects-data.js</li>
                                    </ul>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    document.getElementById('resume-content').innerHTML = resumeHTML;
                    
                } catch (fallbackError) {
                    console.error('Error generating fallback content:', fallbackError);
                    document.getElementById('resume-content').innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <h3 style="color: #999;">Resume Unavailable</h3>
                            <p style="margin: 20px 0;">Add <strong>resume.pdf</strong> to the root directory to display your resume.</p>
                            <p style="margin: 10px 0; font-size: 14px;">Alternatively, populate data files:</p>
                            <ul style="list-style: none; padding: 0;">
                                <li>data/experience.json</li>
                                <li>data/skills.json</li>
                                <li>js/projects-data.js</li>
                            </ul>
                        </div>
                    `;
                }
            }
        }
        
        // Main transformation sequence
        async function transformToResume() {
            console.log('transformToResume called', { isTransformingToResume, isResumeMode });
            
            if (isTransformingToResume || isResumeMode) {
                console.log('Already transforming or in resume mode, returning');
                return;
            }
            
            console.log('Starting transformation...');
            isTransformingToResume = true;
            
            // Hide header title if still visible
            const headerTitle = document.getElementById('header-title');
            if (headerTitle && headerTitle.style.display !== 'none') {
                headerTitle.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
                headerTitle.style.opacity = '0';
                headerTitle.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => {
                    headerTitle.style.display = 'none';
                }, 500);
            }
            
            // Fade out UI elements
            const uiElements = [
                document.getElementById('detail-card'),
                document.getElementById('projects-panel'),
                document.getElementById('theme-toggle'),
                document.getElementById('resume-toggle'),
                document.getElementById('navigation'),
                document.getElementById('skill-legend'),
                document.getElementById('experience-section'),
                document.getElementById('roots-content'),
                document.getElementById('projects-toggle'),
                document.getElementById('legend-toggle'),
                document.getElementById('trunk-ui'),
                document.getElementById('roots-panel')
            ];
            
            uiElements.forEach(el => {
                if (el) {
                    el.style.transition = 'opacity 0.5s ease-out';
                    el.style.opacity = '0';
                    setTimeout(() => { el.style.display = 'none'; }, 500);
                }
            });
            
            if (typeof hideCallout === 'function') {
                hideCallout(false);
            }
            
            // Disable callout loop during transformation
            enableAutoCallouts = false;
            if (typeof hideCallout === 'function') {
                hideCallout(false);
            }
            
            // Hide roots and experience section
            skillTree.tree.traverse((obj) => {
                // Hide trunk/roots meshes
                if (obj.userData && (obj.userData.isTrunk || obj.userData.isRoot)) {
                    obj.visible = false;
                }
            });
            
            console.log('1. Starting camera animation to trunk...');
            // 1. Camera zooms to trunk
            await animateCameraToTrunk();
            console.log('1. Camera animation complete');
            
            console.log('2. Starting axe chop animation...');
            // 2. Axe chops tree
            await animateAxeChop();
            console.log('2. Axe chop complete');
            
            console.log('3. Starting tree falling animation...');
            // 3. Tree falls over
            await animateTreeFalling();
            console.log('3. Tree falling complete');
            
            console.log('4. Starting paper machine animation...');
            // 4. Tree transforms to paper machine
            await animatePaperMachine();
            console.log('4. Paper machine complete');
            
            console.log('5. Creating and animating paper plane...');
            // 5. Paper plane appears
            const paper = createPaperPlane();
            await animatePaperAppear(paper);
            console.log('5. Paper plane complete');
            
            console.log('6. Loading resume content...');
            // 6. Show resume content
            await loadResumeContent();
            document.getElementById('resume-container').classList.add('visible');
            document.getElementById('recycle-tree').classList.add('visible');
            console.log('6. Resume content loaded');
            
            isResumeMode = true;
            isTransformingToResume = false;
            console.log('Transformation complete!');
        }
        
        // Transform back to tree
        async function transformToTree() {
            if (isTransformingToResume || !isResumeMode) return;
            
            isTransformingToResume = true;
            
            // Fade out resume first
            const resumeContainer = document.getElementById('resume-container');
            resumeContainer.style.opacity = '0';
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Hide resume
            resumeContainer.classList.remove('visible');
            document.getElementById('back-to-tree').classList.remove('visible');
            
            // Remove paper plane
            const toRemove = [];
            scene.children.forEach(child => {
                if (child instanceof THREE.Mesh && child.geometry instanceof THREE.PlaneGeometry) {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(obj => scene.remove(obj));
            
            // Remove old fallen tree completely
            if (skillTree.tree) {
                scene.remove(skillTree.tree);
            }
            
            // Reset camera to original position
            camera.position.set(0, 0, 20);
            camera.rotation.set(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
            
            // Rebuild tree from scratch with animation
            skillTree.tree = null;
            skillTree.nodes = [];
            skillTree.branches = [];
            skillTree.isAnimating = true;
            skillTree.buildProgress = 0;
            
            // Rebuild the tree structure
            await skillTree.buildTree(skillTree.hierarchyData);
            
            // Show roots and trunk again
            if (skillTree.tree) {
                skillTree.tree.traverse((obj) => {
                    if (obj.userData && (obj.userData.isTrunk || obj.userData.isRoot)) {
                        obj.visible = true;
                    }
                });
            }
            
            // Re-enable controls and callouts
            controls.enabled = true;
            enableAutoCallouts = true;
            
            // Fade UI elements back in
            const uiElements = [
                document.getElementById('detail-card'),
                document.getElementById('projects-panel'),
                document.getElementById('theme-toggle'),
                document.getElementById('resume-toggle'),
                document.getElementById('navigation'),
                document.getElementById('skill-legend'),
                document.getElementById('experience-section'),
                document.getElementById('roots-content'),
                document.getElementById('projects-toggle'),
                document.getElementById('legend-toggle')
            ];
            
            uiElements.forEach(el => {
                if (el) {
                    el.style.display = 'block';
                    el.style.opacity = '0';
                    setTimeout(() => {
                        el.style.transition = 'opacity 0.5s ease-in';
                        el.style.opacity = '1';
                    }, 50);
                }
            });
            
            isResumeMode = false;
            isTransformingToResume = false;
        }
        
        // Recycle and replant tree with seed intro
        async function recycleAndReplant() {
            if (isTransformingToResume) return;
            
            // Fade out resume first
            const resumeContainer = document.getElementById('resume-container');
            if (resumeContainer) {
                resumeContainer.style.opacity = '0';
            }
            
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Hide resume and recycle button
            if (resumeContainer) resumeContainer.classList.remove('visible');
            const recycleBtn = document.getElementById('recycle-tree');
            if (recycleBtn) recycleBtn.classList.remove('visible');
            
            // Full page reload for clean reset
            window.location.reload();
        }
        
        // Add event listeners
        const resumeToggleBtn = document.getElementById('resume-toggle');
        const backToTreeBtn = document.getElementById('back-to-tree');
        const recycleBtn = document.getElementById('recycle-tree');
        
        if (resumeToggleBtn) {
            resumeToggleBtn.addEventListener('click', () => {
                console.log('Resume toggle clicked');
                transformToResume();
            });
        } else {
            console.error('Resume toggle button not found!');
        }
        
        if (backToTreeBtn) {
            backToTreeBtn.addEventListener('click', transformToTree);
        }
        
        if (recycleBtn) {
            recycleBtn.addEventListener('click', recycleAndReplant);
        }
        
        // ===== ANIMATION LOOP =====
        let time = 0;
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Calculate delta time in seconds
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            controls.update();
            
            time += 0.01;
            
            // Update build animation
            skillTree.updateBuildAnimation(deltaTime);
            
            // Apply throb animation to hovered node (disable on mobile for performance)
            if (hoveredNode && !isZoomedIn && !isMobile) {
                const throbScale = 1 + Math.sin(time * 5) * 0.15; // Pulse between 0.85x and 1.15x
                const targetScale = hoveredNode.userData.targetScale;
                if (targetScale) {
                    hoveredNode.scale.set(
                        targetScale.x * throbScale,
                        targetScale.y * throbScale,
                        targetScale.z * throbScale
                    );
                }
            } else if (hoveredNode && hoveredNode.userData.targetScale) {
                // Reset to normal scale when not hovering
                hoveredNode.scale.copy(hoveredNode.userData.targetScale);
            }
            
            // Update callout line to follow rotation
            updateCalloutLine();
            
            // Check if we should auto-resume callouts (after 3 seconds of idle) - only on desktop
            if (enableAutoCallouts && window.treeAnimationComplete && !hoveredNode && !isZoomedIn && !currentCalloutNode && !isCalloutFading) {
                const timeSinceInteraction = Date.now() - lastInteractionTime;
                if (timeSinceInteraction > 3000) {
                    // Reset timer and show callout
                    lastInteractionTime = Date.now();
                    showRandomCallout();
                }
            }
            
            // Slow rotation (pause when node selected, hovered, or during build animation, or transforming)
            if (skillTree.tree && !skillTree.selectedNode && !skillTree.isAnimating && !hoveredNode && !isTransformingToResume) {
                skillTree.tree.rotation.y += isMobile ? 0.001 : 0.002; // Slower rotation on mobile
            }
            
            // Keep paper plane facing camera in resume mode
            if (isResumeMode) {
                scene.children.forEach(child => {
                    if (child.userData && child.userData.isPaper) {
                        child.lookAt(camera.position);
                    }
                });
            }
            
            // Scale trunk-ui with camera zoom
            const trunkUI = document.getElementById('trunk-ui');
            if (trunkUI && !isResumeMode && !isTransformingToResume) {
                // Calculate scale based on camera distance (default is 20)
                const defaultDistance = 20;
                const currentDistance = camera.position.length();
                // Invert scaling: closer = shorter, farther = taller
                const scale = Math.pow(currentDistance / defaultDistance, 1.5);
                // Clamp scale between 0.3 and 3.0 for wider range
                const clampedScale = Math.max(0.3, Math.min(3.0, scale));
                trunkUI.style.transform = `translateX(-50%) scaleY(${clampedScale})`;
                
                // Update trunk position to match roots panel height
                const rootsPanel = document.getElementById('roots-panel');
                if (rootsPanel) {
                    const rootsHeight = rootsPanel.offsetHeight;
                    trunkUI.style.bottom = `${rootsHeight}px`;
                }
            }
            
            skillTree.update(time);
            
            renderer.render(scene, camera);
        }
        
        animate(0);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update callout line canvas size
            calloutLine.width = window.innerWidth;
            calloutLine.height = window.innerHeight;
        });
    </script>
</body>
</html>